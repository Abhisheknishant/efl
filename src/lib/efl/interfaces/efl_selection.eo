import efl_selection_types;

interface Efl.Selection {
   [[Efl Copy and Paste class]]
   //legacy_prefix: elm_cnp;
   //eo_prefix: efl_selection;
   methods {
      selection_set {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            @in format: Efl.Selection.Format; [[Selection Format]]
            @in buf: const(void_ptr);
            @in len: int; [[The buffer's length.]]
            //@in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
            @in seat: uint @optional;[[Specified seat for multiple seats case.]]
         }
      }
      selection_get {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            @in format: Efl.Selection.Format; [[Selection Format]]
            @in data_func: Efl.Selection.Data_Ready; [[Data ready function pointer]]
            //@in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
            @in seat: uint @optional;[[Specified seat for multiple seats case.]]
         }
      }
      selection_clear {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            //@in seat: Efl.Input.Device @optional; [[Specified seat for multiple seats case.]]
            @in seat: uint @optional; [[Specified seat for multiple seats case.]]
         }
      }
      has_owner {
         params {
            @in seat: uint @optional; [[Specified seat for multiple seats case.]]
         }
         return: bool;
      }
      /*selection_loss_feedback { //name!!!
         params {
            @in type: Efl.Selection.Type; [[Selection type]]
         }
         return: future<generic_value>; [[Future of selection that is ready]]
      }*/
   }
   implements {
   }
   events {
      selection,loss; [[Called when selection has lost]]
      selection,changed; [[Called when display server's selection has changed]]
   }
}
