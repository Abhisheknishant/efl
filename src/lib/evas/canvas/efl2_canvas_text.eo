// Textblock

import eina_types;

const efl_text_object_replacement: Eina.Unicode = 0xFFFCU;
const efl_text_paragraph_separator: Eina.Unicode = 0x2029U;
const efl_text_object_replacement_utf8: string = "\xEF\xBF\xBC";
const efl_text_paragraph_separator_utf8: string = "\xE2\x80\xA9";

struct @extern Efl2.Canvas.Text_Style;
struct @beta Efl2.Text.Attribute.Handle;

/* FIXME:
    missing:
        - pango_layout_set_indent equivalent
*/
class @beta Efl2.Canvas.Text extends Efl.Canvas.Object implements Efl2.Text.Content.Markup,
                       Efl.Canvas.Filter.Internal, Efl2.Text.Wrap.Properties, Efl.Ui.I18n
{
   [[Efl canvas text class]]
   methods {
      @property vertical_align {
         [[Vertical alignment of text]]
         set {}
         get {}
         values {
            value: double; [[Vertical alignment value]]
         }
      }

      @property is_empty {
         [[Whether the object is empty (no text) or not
         ]]
         get {
         }
         values {
            is_empty: bool; [[$true if empty, $false otherwise]]
         }
      }
      @property is_ellipsized {
         [[Whether the text was ellipsized to fit or not
         ]]
         get {
         }
         values {
            ellipsized: bool; [[$true if it was ellipsized, $false otherwise]]
         }
      }

      @property multiline {
         [[Multiline is enabled or not]]
         values {
            enabled: bool; [[$true if multiline is enabled, $false otherwise]]
         }
      }

      visible_range_get {
         [[Returns the currently visible range.

           The given $start and $end cursor act like out-variables here,
           as they are set to the positions of the start and the end of the
           visible range in the text, respectively.
         ]]
         return: bool; [[$true on success, $false otherwise]]
         params {
            @in start: Efl2.Text.Cursor; [[Range start position]]
            @in end: Efl2.Text.Cursor; [[Range end position]]
         }
      }

      cursor_handle_new {
         [[Creates a new cursor handle associated with the text object]]
         return: Efl2.Text.Cursor_Handle @by_ref; [[The new cursor handle]]
      }
      cursor_handle_free {
         [[Creates a new cursor handle associated with the text object]]
         params {
             cur: Efl2.Text.Cursor_Handle @by_ref; [[The new cursor handle]]
         }
      }

      // FIXME: Do extents instead? Also Pango has ink and logical pango_layout_get_extents -> check what that means.
      @property style_insets {
         [[Gets the left, right, top and bottom insets of the text.

           The inset is any applied padding on the text.

           Will trigger a relayout of the object if it's not already layed out.
         ]]
         get {}
         values {
            l: int; [[Left padding]]
            r: int; [[Right padding]]
            t: int; [[Top padding]]
            b: int; [[Bottom padding]]
         }
      }
      @property newline_as_paragraph_separator {
         [[When $true, newline character will behave as a paragraph separator.
         ]]
         set {}
         get {}
         values {
            mode: bool; [[$true for legacy mode, $false otherwise]]
         }
      }
      // FIXME: updatedocs + am I happy with this?
      // Need to update the actual text_style object so it can be manipulated with new bindable functions.
      // Make it an eo object so it's bindable? Will also let us have interfaces/functions on item.
      // Try to make it compatible with the old styles so they could be shared thanks to edje (and be created from edje)
      text_style_push {
         [[Add a text style to the object
         ]]
         params {
            style: Efl2.Canvas.Text_Style @by_ref; [[The style to apply]]
         }
      }
      text_style_pop {
         [[Remove a text style from the object
         ]]
         return: bool; [[If succeededd]]
      }
      text_style_peek @const {
         [[Peek at the top text style of the object
         ]]
         return: Efl2.Canvas.Text_Style @by_ref; [[The most recent style added]]
      }
      @property size_formatted {
         [[The formatted width and height.

           This calculates the actual size after restricting the
           textblock to the current size of the object.

           The main difference between this and @.size_native.get
           is that the "native" function does not wrapping into account
           it just calculates the real width of the object if it was
           placed on an infinite canvas, while this function gives the
           size after wrapping according to the size restrictions of the
           object.

           For example for a textblock containing the text:
           "You shall not pass!" with no margins or padding and assuming
           a monospace font and a size of 7x10 char widths (for simplicity)
           has a native size of 19x1 and a formatted size of 5x4.
         ]]
         get {}
         values {
            size: Eina.Size2D; [[The size of the object]]
         }
      }
      @property size_native {
         [[The native width and height.

           This calculates the actual size without taking account the
           current size of the object.

           The main difference between this and @.size_formatted.get
           is that the "native" function does not take wrapping into
           account it just calculates the real width of the object if
           it was placed on an infinite canvas, while the "formatted"
           function gives the size after  wrapping text according to
           the size restrictions of the object.

           For example for a textblock containing the text:
           "You shall not pass!" with no margins or padding and assuming
           a monospace font and a size of 7x10 char widths (for simplicity)
           has a native size of 19x1 and a formatted size of 5x4.
         ]]
         get {}
         values {
            size: Eina.Size2D; [[The size of the object]]
         }
      }
      // Obstacles
      obstacle_add {
         [[Add obstacle evas object $eo_obs to be observed during layout
           of text.

           The textblock does the layout of the text according to the
           position of the obstacle.
         ]]
         params {
            @in eo_obs: Efl.Canvas.Object; [[Obstacle object]]
         }
         return: bool; [[$true on success, $false otherwise.]]
      }
      obstacle_remove {
         [[Removes $eo_obs from observation during text layout.
         ]]
         params {
            @in eo_obs: Efl.Canvas.Object; [[Obstacle object]]
         }
         return: bool; [[$true on success, $false otherwise.]]
      }
      // FIXME: Needs to be removed! It should just keep callbacks on those objects and update the flag when they change
      // obstacles_update {
      async_layout {
         [[Requests to layout the text off the mainloop.
         ]]
      }
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.destructor;
      Efl.Canvas.Object.paragraph_direction { get; set; }
      Efl2.Text.Content.Plain.text { get; set; }
      Efl.Gfx.Filter.filter_program { get; set; }
      Efl.Gfx.Filter.filter_data { get; set; }
      Efl.Gfx.Filter.filter_source { get; set; }
      Efl.Canvas.Filter.Internal.filter_dirty;
      Efl.Canvas.Filter.Internal.filter_input_render;
      Efl.Canvas.Filter.Internal.filter_state_prepare;
      Efl2.Text.Wrap.Properties.ellipsis { get; set; }
      Efl2.Text.Wrap.Properties.wrap { get; set; }
      Efl.Gfx.Entity.scale { set; }
   }
   events {
       // FIXME: define when changed is actually called compared to layout. I guess chaged is called everything time content changes, and layout one just after layout is done.
      changed: void; [[Called when text content changes]] // FIXME: rename to content,changed?
      attributes,changed: void; [[Called when attributes change]]
      layout,finished: void; [[Called when the object has been layed out]]

      // FIXME: rename if we rename the property
      style_insets,changed: void; [[Called when the property @.style_insets changed.]]
   }
}
