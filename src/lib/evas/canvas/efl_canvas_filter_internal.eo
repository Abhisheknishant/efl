// import efl_gfx_types -> need to add Efl.Gfx.Color

/* Everything in this file is internal to Evas. It is not meant to be used
   from outside EFL itself! */

struct Efl.Gfx.Color32
{
   r: uint8;
   g: uint8;
   b: uint8;
   a: uint8;
}

struct Efl.Canvas.Filter.State_Name
{
   name: string;
   value: double;
}

struct Efl.Canvas.Filter.State_Text
{
   outline: Efl.Gfx.Color32;
   shadow: Efl.Gfx.Color32;
   glow: Efl.Gfx.Color32;
   glow2: Efl.Gfx.Color32;
}

struct Efl.Canvas.Filter.State
{
   [[Internal structure representing the state of a Gfx Filter]]
   text: Efl.Canvas.Filter.State_Text;
   color: Efl.Gfx.Color32;
   cur: Efl.Canvas.Filter.State_Name;
   next: Efl.Canvas.Filter.State_Name;
   w: int;
   h: int;
   scale: double;
   pos: double;
}

mixin Efl.Canvas.Filter.Internal (Efl.Gfx.Filter, Efl.Object)
{
   [[Evas internal implementation of filters.]]

   eo_prefix: evas;
   data: Evas_Filter_Data;

   methods {
      @property filter_changed @protected {
         set {
            [[Marks this filter as changed.]]
         }
         values {
            val: bool; [[$true if filter changed, $false otherwise]]
         }
      }
      @property filter_invalid @protected {
         set {
            [[Marks this filter as invalid.]]
         }
         values {
            val: bool; [[$true if filter is invalid, $false otherwise]]
         }
      }
      filter_input_alpha @protected @pure_virtual {
         [[Called by Efl.Canvas.Filter.Internal to determine whether the input is alpha or rgba.]]
         return: bool; [[$true on success, $false otherwise]]
      }
      filter_state_prepare @protected @pure_virtual {
         [[Called by Efl.Canvas.Filter.Internal to request the parent class
           for state information (color, etc...).]]
         params {
            @out state: Efl.Canvas.Filter.State; [[State info to fill in]]
            @in data: void_ptr; [[Private data for the class]]
         }
      }
      filter_input_render @protected @pure_virtual {
         [[Called by Efl.Canvas.Filter.Internal when the parent class must render the input.]]
         return: bool; [[Indicates success from the object render function.]]
         params {
            filter: void_ptr; [[Current filter context]]
            drawctx: void_ptr; [[Draw context (for evas engine)]]
            data: void_ptr; [[Arbitrary private data]]
            l: int; [[Left]]
            r: int; [[Right]]
            t: int; [[Top]]
            b: int; [[Bottom]]
            x: int; [[X offset]]
            y: int; [[Y offset]]
            do_async: bool; [[$true when the operation should be done asynchronous, $false otherwise]]
         }
      }
      filter_dirty @protected @pure_virtual {
         [[Called when the filter changes must trigger a redraw of the object.

           Virtual, to be implemented in the parent class.
         ]]
      }
      @property filter_output_buffer @protected {
         get {
            [[Retrieve cached output buffer, if any.

              Does not increment the reference count.
            ]]
         }
         values {
            buffer: void_ptr; [[Output buffer]]
         }
      }
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.destructor;
      Efl.Gfx.Filter.filter_program { get; set; }
      Efl.Gfx.Filter.filter_state { get; set; }
      Efl.Gfx.Filter.filter_padding { get; }
      Efl.Gfx.Filter.filter_source { get; set; }
      Efl.Gfx.Filter.filter_data { get; set; }
   }
}
