type @extern Evas_Object_Image_Pixels_Get_Cb: __undefined_type; /* FIXME: func pointers are not supported. */

class Evas.Image (Evas.Object, Efl.File, Efl.Image, Efl.Image_Load, Efl.Image_Animated, Efl.Gfx.Buffer, Efl.Gfx.Fill, Efl.Gfx.View, Evas.Filter)
{
   legacy_prefix: evas_object_image;
   eo_prefix: evas_obj_image;
   methods {
      /* PROXY stuff */
      @property source_clip {
         set {
            [[Clip the proxy object with the source object's clipper.

              @since 1.8
            ]]
         }
         get {
            [[Determine whether an object is clipped by source object's
              clipper.

              @since 1.8
            ]]
         }
         values {
            source_clip: bool; [[Whether $obj is clipped by the source
                                clipper ($true) or not ($false).]]
         }
      }
      @property source {
         set {
            [[Set the source object on an image object to used as a proxy.

              If an image object is set to behave as a proxy, it will mirror
              the rendering contents of a given source object in its drawing
              region, without affecting that source in any way. The source
              must be another valid Evas object. Other effects may be
              applied to the proxy, such as a map (see
              \@ref evas_object_map_set) to create a reflection of the
              original object (for example).

              Any existing source object on $obj will be removed after this
              call. Setting $src to $null clears the proxy object (not in
              "proxy state" anymore).

              Warning: You cannot set a proxy as another proxy's source.
            ]]
            return: bool;
         }
         get {
            [[Get the current source object of an image object.]]
         }
         values {
            src: Evas.Object *; [[Source object to use for the proxy.]]
         }
      }
      @property source_visible {
         set {
            [[Set the source object to be visible or not.

              If $visible is set to $false, the source object of the
              proxy ($obj) will be invisible.

              This API works differently to \@ref evas_object_show and
              \@ref evas_object_hide. Once source object is hidden, the
              proxy object will be hidden as well. Actually in this case
              both objects are excluded from the Evas internal update circle.

              By this API, instead, one can toggle the visibility of a
              proxy's source  object remaining the proxy visibility untouched.

              Warning: If the all of proxies are deleted, then the source
              visibility of the source object will be cancelled.

              @since 1.8
            ]]
         }
         get {
            [[Get the state of the source object visibility.

              @since 1.8
            ]]
         }
         values {
            visible: bool; [[$true is source object to be shown, $false
                             otherwise.]]
         }
      }
      @property source_events {
         set {
            [[Set whether an Evas object is to source events.

              Set whether an Evas object is to repeat events to source.

              If $source is $true, it will make events on $obj to also be
              repeated for the source object (see @.source.set). Even the
              $obj and source geometries are different, the event position
              will be transformed to the source object's space.

              If $source is $false, events occurring on $obj will be
              processed only on it.

              @since 1.8
            ]]
         }
         get {
            [[Determine whether an object is set to source events.

              @since 1.8
            ]]
         }
         values {
            source: bool; [[Whether $obj is to pass events ($true) or not
                            ($false).]]
         }
      }

      /* weird stuff - hints */
      @property content_hint {
         set {
            [[Set the content hint setting of a given image object of the
              canvas.

              This function sets the content hint value of the given image
              of the canvas. For example, if you're on the GL engine and
              your driver implementation supports it, setting this hint to
              #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need zero copies
              at texture upload time, which is an "expensive" operation.
            ]]
         }
         get {
            [[Get the content hint setting of a given image object of the
              canvas.

              This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.
            ]]
         }
         values {
            hint: Evas.Image_Content_Hint; [[The content hint value, one of
                                             the @Evas.Image_Content_Hint ones.]]
         }
      }
      @property scale_hint {
         set {
            [[Set the scale hint of a given image of the canvas.

              This function sets the scale hint value of the given image
              object in the canvas, which will affect how Evas is to cache
              scaled versions of its original source image.
            ]]
         }
         get {
            [[Get the scale hint of a given image of the canvas.

              This function returns the scale hint value of the given image
              object of the canvas.
            ]]
         }
         values {
            hint: Evas.Image_Scale_Hint; [[The scale hint, a value in
                                           @Evas.Image_Scale_Hint.]]
         }
      }

      /* GL View */
      @property pixels_dirty {
         set {
            [[Mark whether the given image object is dirty and needs to
              request its pixels.

              This function will only properly work if a pixels get
              callback has been set.

              Warning: Use this function if you really know what you are
              doing.
            ]]
         }
         get {
            [[Retrieves whether the given image object is dirty (needs to
              be redrawn).
            ]]
         }
         values {
            dirty: bool; [[Whether the image is dirty.]]
         }
      }
      @property pixels_get_callback {
         set {
            [[Set the callback function to get pixels from a canvas' image.

              This functions sets a function to be the callback function
              that get pixels from a image of the canvas.
            ]]
         }
         values {
            func: Evas_Object_Image_Pixels_Get_Cb @nonull; [[The callback function.]]
            data: void *; [[The data pointer to be passed to $func.]]
         }
      }

      /* Video */
      @property video_surface {
         set {
            [[Set the video surface linked to a given image of the canvas.

              @since 1.1
            ]]
            values {
               surf: Evas.Video_Surface*; [[The new video surface.]]
            }
         }
         get {
            [[Get the video surface linekd to a given image of the canvas.

              @since 1.1
            ]]
            values {
               surf: const(Evas.Video_Surface)*; [[The new video surface.]]
            }
         }
      }
      @property video_surface_caps {
         set {
            [[Set the video surface capabilities to a given image of the canvas.]]
         }
         get {
            [[Get the video surface capabilities to a given image of the canvas.]]
         }
         values {
            caps: uint;
         }
      }

      /* native surface */
      @property native_surface {
         set {
            [[Set the native surface of a given image of the canvas

              This function sets a native surface of a given canvas image.
            ]]
            legacy: null;
         }
         get {
            [[Get the native surface of a given image of the canvas

              This function returns the native surface of a given canvas
              image.
            ]]
         }
         values {
            surf: Evas.Native_Surface* @nonull; [[The native surface.]]
         }
      }
      @property data_copy {
         set {
            [[Replaces the raw image data of the given image object.

              This function lets the application replace an image object's
              internal pixel buffer with an user-allocated one. For best
              results, you should generally first call
              \@ref evas_object_image_size_set with the width and height
              for the new buffer.

              This call is best suited for when you will be using image
              data with different dimensions than the existing image data,
              if any. If you only need to modify the existing image in some
              fashion, then using @.data_get is probably what you are after.

              Note that the caller is responsible for freeing the buffer
              when finished with it, as user-set image data will not be
              automatically freed when the image object is deleted.
            ]]
         }
         values {
            data: void *; [[The raw data to replace.]]
         }
      }

      /* 3d */
      @property scene {
         set {
            [[Set the 3D scene of a given image of the canvas.

              This function sets a 3d scene of a given canvas image.

              @since 1.10
            ]]
            legacy: null;
         }
         get {
            [[Get the 3D scene of a given image of the canvas.

              This function returns the 3d scene of a given canvas image.

              @since 1.10
            ]]
            legacy: null;
         }
         values {
            scene: Evas.Canvas3D.Scene *; [[3D scene on an image object.]]
         }
      }
      @property snapshot {
         set {
            [[The content below the Evas_Object_Image will be rendered
              inside it and you can reuse it as a source for any kind
              of effect.

              @since 1.15
            ]]
         }
         get {
            [[Determine wether the Evas_Object_Image replicate the content
              of the canvas below.

              @since 1.15
            ]]
         }
         values {
            s: bool; [[Wether to put the content of the canvas below inside
                       the Evas_Object_Image.]]
         }
      }
      data_set {
         [[Sets the raw image data of the given image object.

           Note that the raw data must be of the same size (see
           \@ref evas_object_image_size_set, which has to be called before
           this one) and colorspace (see \@.colorspace.set) of the image.
           If data is $null, the current image data will be freed.
           Naturally, if one does not set an image object's data
           manually, it will still have one, allocated by Evas.
         ]]
         params {
            @in data: void *; [[The raw data, or $null.]]
         }
      }
      data_get @const {
         [[Get a pointer to the raw image data of the given image object.

           This function returns a pointer to an image object's internal
           pixel buffer, for reading only or read/write. If you request
           it for writing, the image will be marked dirty so that it gets
           redrawn at the next update.

           Each time you call this function on an image object, its data
           buffer will have an internal reference counter incremented.
           Decrement it back by using @.data_set.

           This is best suited for when you want to modify an existing
           image, without changing its dimensions.

           Note: The contents' format returned by it depend on the color
           space of the given image object.

           Note: You may want to use \@.data_update_add to inform data
           changes, if you did any.
         ]]
         return: void * @warn_unused; [[ The raw image data.]]
         params {
            @in for_writing: bool; [[Whether the data being retrieved will
                                     be modified ($true) or not ($false).]]
         }
      }
   }
   implements {
      Eo.Base.constructor;
      Eo.Base.destructor;
      Eo.Base.dbg_info_get;
      Eo.Base.finalize;
      Efl.File.file.set;
      Efl.File.file.get;
      Efl.File.mmap.set;
      Efl.File.mmap.get;
      Efl.File.save;
      Efl.Image.orientation.get;
      Efl.Image.orientation.set;
      Efl.Image.alpha.get;
      Efl.Image.alpha.set;
      Efl.Image.smooth_scale.set;
      Efl.Image.smooth_scale.get;
      Efl.Image.ratio.get;
      Efl.Image.border.get;
      Efl.Image.border.set;
      Efl.Image.border_scale.get;
      Efl.Image.border_scale.set;
      Efl.Image.border_center_fill.get;
      Efl.Image.border_center_fill.set;
      Efl.Image_Animated.animated.get;
      Efl.Image_Animated.animated_frame.get;
      Efl.Image_Animated.animated_frame.set;
      Efl.Image_Animated.animated_frame_count.get;
      Efl.Image_Animated.animated_loop_type.get;
      Efl.Image_Animated.animated_loop_count.get;
      Efl.Image_Animated.animated_frame_duration.get;
      Efl.Image_Load.load_error.get;
      Efl.Image_Load.load_async_start;
      Efl.Image_Load.load_async_cancel;
      Efl.Image_Load.load_dpi.get;
      Efl.Image_Load.load_dpi.set;
      Efl.Image_Load.load_size.set;
      Efl.Image_Load.load_size.get;
      Efl.Image_Load.load_orientation.get;
      Efl.Image_Load.load_orientation.set;
      Efl.Image_Load.load_scale_down.get;
      Efl.Image_Load.load_scale_down.set;
      Efl.Image_Load.load_region.get;
      Efl.Image_Load.load_region.set;
      Efl.Image_Load.load_region_support.get;
      Efl.Gfx.Buffer.buffer_update_region_add;
      Efl.Gfx.Buffer.buffer_stride.get;
      Efl.Gfx.Buffer.colorspace.get;
      Efl.Gfx.Fill.fill.set;
      Efl.Gfx.Fill.fill.get;
      Efl.Gfx.Fill.filled.get;
      Efl.Gfx.Fill.filled.set;
      Efl.Gfx.View.view_size.set;
      Efl.Gfx.View.view_size.get;
      Efl.Gfx.Filter.filter_program.set;
      Evas.Filter.filter_input_alpha;
      Evas.Filter.filter_input_render;
      Evas.Filter.filter_dirty;
   }
}
