type @extern Evas_Object_Image_Pixels_Get_Cb: __undefined_type; /* FIXME: func pointers are not supported. */

class Evas.Image (Evas.Object, Efl.File, Efl.Image, Efl.Image_Load, Efl.Image_Animated, Efl.Gfx.Buffer, Efl.Gfx.Fill, Efl.Gfx.View, Evas.Filter)
{
   legacy_prefix: evas_object_image;
   eo_prefix: evas_obj_image;
   methods {
      /* PROXY stuff */
      @property source_clip {
         set {
            [[Clip the proxy object with the source object's clipper.

              @since 1.8
            ]]
         }
         get {
            [[Determine whether an object is clipped by source object's
              clipper.

              @since 1.8
            ]]
         }
         values {
            source_clip: bool; [[Whether $obj is clipped by the source
                                clipper ($true) or not ($false).]]
         }
      }
      @property source {
         set {
            [[Set the source object on an image object to used as a proxy.

              If an image object is set to behave as a proxy, it will mirror
              the rendering contents of a given source object in its drawing
              region, without affecting that source in any way. The source
              must be another valid Evas object. Other effects may be
              applied to the proxy, such as a map (see
              \@ref evas_object_map_set) to create a reflection of the
              original object (for example).

              Any existing source object on $obj will be removed after this
              call. Setting $src to $null clears the proxy object (not in
              "proxy state" anymore).

              Warning: You cannot set a proxy as another proxy's source.
            ]]
            return: bool;
         }
         get {
            [[Get the current source object of an image object.]]
         }
         values {
            src: Evas.Object *; [[Source object to use for the proxy.]]
         }
      }
      @property source_visible {
         set {
            [[Set the source object to be visible or not.

              If $visible is set to $false, the source object of the
              proxy ($obj) will be invisible.

              This API works differently to \@ref evas_object_show and
              \@ref evas_object_hide. Once source object is hidden, the
              proxy object will be hidden as well. Actually in this case
              both objects are excluded from the Evas internal update circle.

              By this API, instead, one can toggle the visibility of a
              proxy's source  object remaining the proxy visibility untouched.

              Warning: If the all of proxies are deleted, then the source
              visibility of the source object will be cancelled.

              @since 1.8
            ]]
         }
         get {
            [[Get the state of the source object visibility.

              @since 1.8
            ]]
         }
         values {
            visible: bool; [[$true is source object to be shown, $false
                             otherwise.]]
         }
      }
      @property source_events {
         set {
            [[Set whether an Evas object is to source events.

              Set whether an Evas object is to repeat events to source.

              If $source is $true, it will make events on $obj to also be
              repeated for the source object (see @.source.set). Even the
              $obj and source geometries are different, the event position
              will be transformed to the source object's space.

              If $source is $false, events occurring on $obj will be
              processed only on it.

              @since 1.8
            ]]
         }
         get {
            [[Determine whether an object is set to source events.

              @since 1.8
            ]]
         }
         values {
            source: bool; [[Whether $obj is to pass events ($true) or not
                            ($false).]]
         }
      }

      /* weird stuff - hints */
      @property content_hint {
         set {
            [[Set the content hint setting of a given image object of the
              canvas.

              This function sets the content hint value of the given image
              of the canvas. For example, if you're on the GL engine and
              your driver implementation supports it, setting this hint to
              #EVAS_IMAGE_CONTENT_HINT_DYNAMIC will make it need zero copies
              at texture upload time, which is an "expensive" operation.
            ]]
         }
         get {
            [[Get the content hint setting of a given image object of the
              canvas.

              This returns #EVAS_IMAGE_CONTENT_HINT_NONE on error.
            ]]
         }
         values {
            hint: Evas.Image_Content_Hint; [[The content hint value, one of
                                             the @Evas.Image_Content_Hint ones.]]
         }
      }
      @property scale_hint {
         set {
            [[Set the scale hint of a given image of the canvas.

              This function sets the scale hint value of the given image
              object in the canvas, which will affect how Evas is to cache
              scaled versions of its original source image.
            ]]
         }
         get {
            [[Get the scale hint of a given image of the canvas.

              This function returns the scale hint value of the given image
              object of the canvas.
            ]]
         }
         values {
            hint: Evas.Image_Scale_Hint; [[The scale hint, a value in
                                           @Evas.Image_Scale_Hint.]]
         }
      }

      /* GL View */
      @property pixels_dirty {
         set {
            [[Mark whether the given image object is dirty and needs to
              request its pixels.

              This function will only properly work if a pixels get
              callback has been set.

              Warning: Use this function if you really know what you are
              doing.
            ]]
         }
         get {
            [[Retrieves whether the given image object is dirty (needs to
              be redrawn).
            ]]
         }
         values {
            dirty: bool; [[Whether the image is dirty.]]
         }
      }
      @property pixels_get_callback {
         set {
            [[Set the callback function to get pixels from a canvas' image.

              This functions sets a function to be the callback function
              that get pixels from a image of the canvas.
            ]]
         }
         values {
            func: Evas_Object_Image_Pixels_Get_Cb @nonull; [[The callback function.]]
            data: void *; [[The data pointer to be passed to $func.]]
         }
      }

      /* Video */
      @property video_surface {
         set {
            [[Set the video surface linked to a given image of the canvas.

              @since 1.1
            ]]
            values {
               surf: Evas.Video_Surface*; [[The new video surface.]]
            }
         }
         get {
            [[Get the video surface linekd to a given image of the canvas.

              @since 1.1
            ]]
            values {
               surf: const(Evas.Video_Surface)*; [[The new video surface.]]
            }
         }
      }
      @property video_surface_caps {
         set {
            [[Set the video surface capabilities to a given image of the canvas.]]
         }
         get {
            [[Get the video surface capabilities to a given image of the canvas.]]
         }
         values {
            caps: uint;
         }
      }

      /* native surface */
      @property native_surface {
         set {
            [[Set the native surface of a given image of the canvas

              This function sets a native surface of a given canvas image.
            ]]
            legacy: null;
         }
         get {
            [[Get the native surface of a given image of the canvas

              This function returns the native surface of a given canvas
              image.
            ]]
         }
         values {
            surf: Evas.Native_Surface* @nonull; [[The native surface.]]
         }
      }

      /* 3d */
      @property scene {
         set {
            [[Set the 3D scene of a given image of the canvas.

              This function sets a 3d scene of a given canvas image.

              @since 1.10
            ]]
            legacy: null;
         }
         get {
            [[Get the 3D scene of a given image of the canvas.

              This function returns the 3d scene of a given canvas image.

              @since 1.10
            ]]
            legacy: null;
         }
         values {
            scene: Evas.Canvas3D.Scene *; [[3D scene on an image object.]]
         }
      }
      @property snapshot {
         set {
            [[The content below the Evas_Object_Image will be rendered
              inside it and you can reuse it as a source for any kind
              of effect.

              @since 1.15
            ]]
         }
         get {
            [[Determine wether the Evas_Object_Image replicate the content
              of the canvas below.

              @since 1.15
            ]]
         }
         values {
            s: bool; [[Wether to put the content of the canvas below inside
                       the Evas_Object_Image.]]
         }
      }
   }
   implements {
      Eo.Base.constructor;
      Eo.Base.destructor;
      Eo.Base.dbg_info_get;
      Eo.Base.finalize;
      Efl.File.file.set;
      Efl.File.file.get;
      Efl.File.mmap.set;
      Efl.File.mmap.get;
      Efl.File.save;
      Efl.Image.orientation.get;
      Efl.Image.orientation.set;
      Efl.Image.alpha.get;
      Efl.Image.alpha.set;
      Efl.Image.smooth_scale.set;
      Efl.Image.smooth_scale.get;
      Efl.Image.ratio.get;
      Efl.Image.border.get;
      Efl.Image.border.set;
      Efl.Image.border_scale.get;
      Efl.Image.border_scale.set;
      Efl.Image.border_center_fill.get;
      Efl.Image.border_center_fill.set;
      Efl.Image_Animated.animated.get;
      Efl.Image_Animated.animated_frame.get;
      Efl.Image_Animated.animated_frame.set;
      Efl.Image_Animated.animated_frame_count.get;
      Efl.Image_Animated.animated_loop_type.get;
      Efl.Image_Animated.animated_loop_count.get;
      Efl.Image_Animated.animated_frame_duration.get;
      Efl.Image_Load.load_error.get;
      Efl.Image_Load.load_async_start;
      Efl.Image_Load.load_async_cancel;
      Efl.Image_Load.load_dpi.get;
      Efl.Image_Load.load_dpi.set;
      Efl.Image_Load.load_size.set;
      Efl.Image_Load.load_size.get;
      Efl.Image_Load.load_orientation.get;
      Efl.Image_Load.load_orientation.set;
      Efl.Image_Load.load_scale_down.get;
      Efl.Image_Load.load_scale_down.set;
      Efl.Image_Load.load_region.get;
      Efl.Image_Load.load_region.set;
      Efl.Image_Load.load_region_support.get;
      Efl.Gfx.Buffer.buffer_update_add;
      Efl.Gfx.Buffer.stride.get;
      Efl.Gfx.Buffer.colorspace.get;
      Efl.Gfx.Fill.fill.set;
      Efl.Gfx.Fill.fill.get;
      Efl.Gfx.Fill.filled.get;
      Efl.Gfx.Fill.filled.set;
      Efl.Gfx.Filter.filter_program.set;
      Efl.Gfx.View.view_size.get;
      Evas.Filter.filter_input_alpha;
      Evas.Filter.filter_input_render;
      Evas.Filter.filter_dirty;
   }
}
