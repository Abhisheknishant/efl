class Evas.Object.Smart (Evas.Object)
{
   legacy_prefix: evas_object_smart;
   eo_prefix: evas_obj_smart;
   data: Evas_Smart_Data;
   methods {
      @property need_recalculate {
         set {
            [[Set or unset the flag signalling that a given smart object needs to
              get recalculated.

              If this flag is set, then the $calculate() smart function of
              $obj will be called, if one is provided, during rendering phase of
              Evas (see evas_render()), after which this flag will be
              automatically unset.

              If that smart function is not provided for the given object, this
              flag will be left unchanged.

              Note: just setting this flag will not make the canvas' whole scene
              dirty, by itself, and evas_render() will have no effect. To
              force that, use evas_object_smart_changed(), that will also
              call this function automatically, with $true as parameter.

              See also @.need_recalculate.get, @.calculate and
              \@ref evas_smart_objects_calculate().]]
         }
         get {
            [[Get the value of the flag signalling that a given smart object needs to
              get recalculated.

              Note: this flag will be unset during the rendering phase, when the
              $calculate() smart function is called, if one is provided.
              If it's not provided, then the flag will be left unchanged
              after the rendering phase.

              See also @.need_recalculate.set, for more details.]]
         }
         values {
            value: bool; [[whether one wants to set ($true) or to unset
                           ($false) the flag.]]
         }
      }
      @property clip {
         set {
            [[No description supplied by the EAPI.]]
            legacy: null;
         }
         values {
            clip: Evas.Object;
         }
      }
      @property color {
         set {
            [[No description supplied by the EAPI.]]
            legacy: null;
         }
         values {
            r: int;
            g: int;
            b: int;
            a: int;
         }
      }
      show {
         [[No description supplied by the EAPI.]]
         legacy: null;
      }
      move {
         [[No description supplied by the EAPI.]]
         legacy: null;
         params {
            @in x: Evas.Coord;
            @in y: Evas.Coord;
         }
      }
      @property smart_no_render {
         [[Propagates the value of no-render to the smart children.]]
         set { legacy: null; }
         values { hide: bool; }
      }
      iterator_new @const {
         [[Retrieves an iterator of the member objects of a given Evas smart object.

           See also @.member_add and @.member_del

           @since 1.8]]
         return: free(own(iterator<Evas.Object>), eina_iterator_free)
            @warn_unused; [[Returns the iterator of the member objects of $obj.]]
      }
      hide {
         [[No description supplied by the EAPI.]]
         legacy: null;
      }
      calculate {
         [[Call the calculate() smart function immediately on a given smart object.

           This will force immediate calculations (see #Evas_Smart_Class)
           needed for renderization of this object and, besides, unset the
           flag on it telling it needs recalculation for the next rendering
           phase.

           See also @.need_recalculate.set]]

      }
      add {
         [[Instantiates a new smart object described by $s.

           This is the function one should use when defining the public
           function adding an instance of the new smart object to a given
           canvas. It will take care of setting all of its internals to work
           as they should, if the user set things properly, as seem on the
           #EVAS_SMART_SUBCLASS_NEW, for example.]]
         legacy: null;
      }
      member_add {
         [[Set an Evas object as a member of a given smart object.

           Members will automatically be stacked and layered together with the
           smart object. The various stacking functions will operate on
           members relative to the other members instead of the entire canvas,
           since they now live on an exclusive layer (see
           evas_object_stack_above(), for more details).

           Any $smart_obj object's specific implementation of the
           $member_add() smart function will take place too, naturally.

           See also @.member_del.]]

         params {
            @in sub_obj: Evas.Object @nonull; [[The member object.]]
         }
         legacy: null;
      }
      resize {
         [[No description supplied by the EAPI.]]
         legacy: null;
         params {
            @in w: Evas.Coord;
            @in h: Evas.Coord;
         }
      }
      clip_unset {
         [[No description supplied by the EAPI.]]
         legacy: null;
      }
      changed {
         [[Mark smart object as changed, dirty.

           This will flag the given object as needing recalculation,
           forcefully. As an effect, on the next rendering cycle its
           calculate() (see #Evas_Smart_Class) smart function will be called.

           See also @.need_recalculate.set and @.calculate.]]

      }
      member_del {
         [[Removes a member object from a given smart object.

           This removes a member object from a smart object, if it was added
           to any. The object will still be on the canvas, but no longer
           associated with whichever smart object it was associated with.

           See also @.member_add for more details.]]

         params {
            @in sub_obj: Evas.Object; [[the member object.]]
         }
         legacy: null;
      }
      del {
         [[Deletes a smart object.]]
         legacy: null;
      }
      move_children_relative {
         [[Moves all children objects of a given smart object relative to a
           given offset.

           This will make each of $obj object's children to move, from where
           they before, with those delta values (offsets) on both directions.

           Note: This is most useful on custom smart $move functions.

           Note: Clipped smart objects already make use of this function on
           their $move smart function definition.
         ]]
         params {
            @in dx: Evas.Coord; [[Horizontal offset (delta).]]
            @in dy: Evas.Coord; [[Vertical offset (delta).]]
         }
      }
   }
   implements {
      class.constructor;
      class.destructor;
      Eo.Base.constructor;
      Evas.Object.paragraph_direction.set;
      Evas.Object.paragraph_direction.get;
   }
}
