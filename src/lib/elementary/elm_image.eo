import evas_image;

struct Elm.Image_Progress
{
   [[
     Structure associated with smart callback 'download,progress'.
     @since 1.8
   ]]
   now:   double;
   total: double;
}

struct Elm.Image.Error
{
   [[
     Structure associated with smart callback 'download,progress'.
     @since 1.8
   ]]
   status:     int;
   open_error: bool;
}

class Elm.Image (Elm.Widget, Evas.Clickable_Interface, Evas.Draggable_Interface,
                 Efl.File, Efl.Image, Efl.Image_Load, Efl.Player, Efl.Gfx.View, Efl.Player,
                 Elm.Interface_Atspi_Image, Elm.Interface_Atspi_Widget_Action,
                 Edje.Object, Efl.Orientation, Efl.Flipable)
{
   eo_prefix: elm_obj_image;
   methods {
      @property fill_inside {
         [[Control the resize method for the object's internal image when maintaining a given aspect ratio.

           If $fill_inside is true, image does not overflow the widget and
           blank spaces are added to fill the space that is still free. If it
           is false, the image overflows the image will fill all space and
           overflow in its larger dimension.

           You can think of it as "fill: inside" or "fill: outside" and not as
           "fill the inside".

           @since 1.7]]
         set {
            legacy: null;
         }
         get {
            legacy: null;
         }
         values {
            fill_inside: bool; [[Resize method for the object's internal image.]]
         }
      }
      @property aspect_fixed {
         set {
            [[Control whether the original aspect ratio of the image should be kept on resize.

              The original aspect ratio (width / height) of the image is usually
              distorted to match the object's size. Enabling this option will retain
              this original aspect, and the way that the image is fit into the object's
              area depends on the option set by @.fill_inside.]]
         }
         get {
         }
         values {
            fixed: bool; [[$true if the image should retain the aspect, $false otherwise.]]
         }
		}
      @property icon {
         set {
            [[Set the image by icon standards names.

              For example, freedesktop.org defines standard icon names such
              as "home", "network", etc. There can be different icon sets to
              match those icon keys. The "name" given as parameter is one of
              these "keys", and will be used to look in the freedesktop.org
              paths and elementary theme.

              If name is not found in any of the expected locations and it is
              the absolute path of an image file, this image will be used.

              Note: The image set by this function can be changed by
              @Efl.File.file.set.

              Note: This function does not accept relative icon path.

              See also @.icon.get.
            ]]
            return: bool; [[true on success, false on error]]
         }
         get {
            [[Get the icon name of image set by icon standard names.

              If the image was set using elm_image_file_set() instead of
              @.icon.set, then this function will return null.
            ]]
         }
         values {
            name: const(char)*; [[The icon name]]
         }
      }
   }
   implements {
      class.constructor;
      Eo.Base.constructor;
      Efl.File.file.set;
      Efl.File.file.get;
      Efl.File.mmap.set;
      Efl.File.async.set;
      Efl.File.async.get;
      Efl.File.async_wait;
      Efl.Gfx.View.view_size.get;
      Efl.Image_Load.load_size.set;
      Efl.Image_Load.load_size.get;
      Efl.Image.smooth_scale.set;
      Efl.Image.smooth_scale.get;
      Efl.Orientation.orientation.set;
      Efl.Orientation.orientation.get;
      Efl.Flipable.flip.set;
      Efl.Flipable.flip.get;
      Efl.Player.playable.get;
      Efl.Player.play.set;
      Efl.Player.play.get;
      Edje.Object.signal_emit;
      Edje.Object.size_min.get;
      Edje.Object.size_max.get;
      Edje.Object.size_min_calc;
      Edje.Object.calc_force;
      Evas.Object_Smart.hide;
      Evas.Object_Smart.clip.set;
      Evas.Object_Smart.clip_unset;
      Evas.Object_Smart.show;
      Evas.Object_Smart.color.set;
      Evas.Object_Smart.move;
      Evas.Object_Smart.add;
      Evas.Object_Smart.del;
      Evas.Object_Smart.member_add;
      Evas.Object_Smart.resize;
      Evas.Draggable_Interface.drag_target.set;
      Evas.Draggable_Interface.drag_target.get;
      Elm.Widget.theme_apply;
      Elm.Widget.event;
      Elm.Interface_Atspi_Image.extents.get;
      Elm.Interface_Atspi_Widget_Action.elm_actions.get;
   }
   events {
      drop;
      download,start;
      download,progress;
      download,done;
      download,error;
   }

}
