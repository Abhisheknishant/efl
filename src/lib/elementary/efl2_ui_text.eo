// elm entry


/* FIXME - Text object must stop using elm_general! */
import elm_general;
import efl2_text_attribute_factory;


enum @beta Efl2.Ui.Selection_Format
{
   [[Selection format]]
   targets = -1, [[For matching every possible atom]]
   none = 0x0, [[Content is from outside of EFL]]
   text = 0x01, [[Plain unformatted text: Used for things that don't want rich markup]]
   markup = 0x2, [[Edje textblock markup, including inline images]]
   image = 0x4, [[Images]]
   vcard = 0x08, [[Vcards]]
   html = 0x10 [[Raw HTML-like data (eg. webkit)]]
}

struct @beta Efl2.Ui.Text_Anchor.Info
{
   [[The event info associated with Anchors]]
   href: string; [[The link set in the anchor.]]
   button: int; [[The mouse button used to click on it.]]
   attribute: Efl2.Text.Attribute.Handle @by_ref; [[The attribute that created this anchor. Can be used to query position and size.]]
}

// FIXME: Gotta figure out dnd and cnp modes.
class @beta Efl2.Ui.Text extends Efl.Ui.Layout_Base implements Efl.Input.Clickable,
                 Efl.Access.Text, Efl.Access.Editable.Text, Efl.File
                 // FIXME composite Efl2.Text.Raw_Editable
{
   [[A flexible text widget which can be static (as a label) or editable by
     the user (as a text entry). It provides all sorts of editing facilities
     like automatic scrollbars, virtual keyboard, clipboard, configurable
     context menus, password mode or autocapitalization, for example.]]
   methods {
      // FIXME: rename and improve doc
      @property valign {
         [[Vertical alignment of text]]
         values {
            value: double; [[Vertical alignment value]]
         }
      }

      @property scrollable {
         [[Enable or disable scrolling in the widget.

           When scrolling is enabled scrollbars will appear if the text does
           not fit the widget size.]]
         set {}
         get {}
         values {
            scroll: bool; [[$true to enable scrolling. Default is $false.]]
         }
      }

      @property cnp_mode {
         /* FIXME: Efl2.Ui.Selection_Format does not allow markup without images! */
         set {
            [[Control pasting of text and images for the widget.

              Normally the entry allows both text and images to be pasted.
              By setting cnp_mode to be #ELM_CNP_MODE_NO_IMAGE this prevents images from being copied or pasted.
              By setting cnp_mode to be #ELM_CNP_MODE_PLAINTEXT this remove all tags in text .

              Note: This only changes the behaviour of text.
            ]]
         }
         get {
            [[Getting elm_entry text paste/drop mode.

              Normally the entry allows both text and images to be pasted.
              This gets the copy & paste mode of the entry.
            ]]
         }
         values {
            format: Efl2.Ui.Selection_Format; [[Format for copy & paste.]]
         }
      }

      cnp_copy {
         [[This executes a "copy" action on the selected text in the entry.]]
      }
      cnp_cut {
         [[This executes a "cut" action on the selected text in the entry.]]
      }
      cnp_paste {
         [[This executes a "paste" action in the entry.]]
      }

      // FIXME: rename?
      @property selection_handler_disabled {
         set {
            [[This disables the entry's selection handlers.]]
         }
         get {
            [[This returns whether the entry's selection handlers are disabled.]]
         }
         values {
            disabled: bool; [[If $true, the selection handlers are disabled.]]
         }
      }

      // FIXME: rename?
      @property context_menu_disabled {
         set {
            [[This disables the entry's contextual (longpress) menu.]]
         }
         get {
            [[This returns whether the entry's contextual (longpress) menu is
              disabled.
            ]]
         }
         values {
            disabled: bool; [[If $true, the menu is disabled.]]
         }
      }
      context_menu_clear {
         [[This clears and frees the items in a entry's contextual (longpress)
           menu.

           See also @.context_menu_item_add.
         ]]
      }

      // FIXME: change "func" to "key" and then have the click callback as a callback on the ui.text object itself
      context_menu_item_add {
         [[This adds an item to the entry's contextual menu.

           A longpress on an entry will make the contextual menu show up unless this
           has been disabled with @.context_menu_disabled.set.
           By default this menu provides a few options like enabling selection mode,
           which is useful on embedded devices that need to be explicit about it.
           When a selection exists it also shows the copy and cut actions.

           With this function, developers can add other options to this menu to
           perform any action they deem necessary.
         ]]
         params {
            @in label: string @optional; [[The item's text label.]]
            @in icon_file: string @optional; [[The item's icon file.]]
            // FIXME: What should be done with this one?
            @in icon_type: Elm.Icon.Type; [[The item's icon type.]]
            @in func: Evas_Smart_Cb @optional; [[The callback to execute when the item is clicked.]]
            @in data: const(void_ptr) @optional; [[The data to associate with the item for related functions.]]
         }
      }
   }
   implements {
      Efl.Object.constructor;
      Efl.Object.finalize;
      Efl.Object.destructor;
      Efl.Gfx.Entity.visible { set; }
      Efl.Gfx.Entity.position { set; }
      Efl.Gfx.Entity.size { set; }
      Efl.Canvas.Group.group_member_add;
      Efl.Canvas.Group.group_calculate;
      Efl.Layout.Signal.signal_callback_add;
      Efl.Layout.Signal.signal_callback_del;
      Efl.Layout.Signal.signal_emit;
      Efl.Ui.Widget.on_access_activate;
      Efl.Ui.Widget.theme_apply;
      Efl.Ui.Focus.Object.on_focus_update;
      Efl.Ui.Widget.interest_region { get; }
      Efl.Ui.Widget.disabled {set;}
      //Efl.Ui.Widget.widget_sub_object_del;
      //Elm.Interface_Scrollable.policy { set; }
      //Elm.Interface_Scrollable.bounce_allow { set; }
      Efl.Access.Object.state_set { get; }
      Efl.Access.Object.i18n_name { get; }
      Efl.Access.Text.access_text { get; }
      Efl.Access.Text.string { get; }
      Efl.Access.Text.attribute { get; }
      Efl.Access.Text.text_attributes { get; }
      Efl.Access.Text.default_attributes { get; }
      Efl.Access.Text.caret_offset { get; set; }
      Efl.Access.Text.character { get; }
      Efl.Access.Text.character_extents { get; }
      Efl.Access.Text.character_count { get; }
      Efl.Access.Text.offset_at_point { get; }
      Efl.Access.Text.bounded_ranges { get; }
      Efl.Access.Text.range_extents { get; }
      Efl.Access.Text.access_selection { get; set; }
      Efl.Access.Text.selections_count { get; }
      Efl.Access.Text.selection_add;
      Efl.Access.Text.selection_remove;
      Efl.Access.Editable.Text.text_content { set; }
      Efl.Access.Editable.Text.insert;
      Efl.Access.Editable.Text.copy;
      Efl.Access.Editable.Text.cut;
      Efl.Access.Editable.Text.delete;
      Efl.Access.Editable.Text.paste;
      Efl.File.file { set; }
      Efl.File.load;
      Efl.Part.part_get;
   }
   events {
       // most/all of the events just come from raw_editable

      context,open: void; [[Called when context menu was opened]]
      context,close: void; [[Called when context menu was closed]]
      // FIXME: here or the layer below??
      anchor,down: Efl2.Ui.Text_Anchor.Info; [[Called on anchor down]]
      anchor,in: Efl2.Ui.Text_Anchor.Info; [[Called on anchor in]]
      anchor,out: Efl2.Ui.Text_Anchor.Info; [[Called on anchor out]]
      anchor,up: Efl2.Ui.Text_Anchor.Info; [[called on anchor up]]

      cnp,paste: void; [[Called when selection is pasted]]
      cnp,copy: void; [[Called when selection is copied]]
      cnp,cut: void; [[Called when selection is cut]]
   }
}
