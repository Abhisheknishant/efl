import efl_selection_types;

/*enum Efl.Selection.Type
{
   [[Selection type]]
   primary, [[Primary text selection (highlighted or selected text)]]
   secondary, [[Used when primary selection is in use]]
   dnd, [[Drag and Drop]]
   clipboard [[Clipboard selectio (ctrl+C)]]
}

//should be more general: Efl.Data.Format???
enum Efl.Selection.Format
{
   [[Selection format]]
   targets = -1, [[For matching every possible atom]]
   none = 0x0, [[Content is from outside of Elementary]]
   text = 0x01, [[Plain unformatted text: Used for things that don't want rich markup]]
   markup = 0x2, [[Edje textblock markup, including inline images]]
   image = 0x4, [[Images]]
   vcard = 0x08, [[Vcards]]
   html = 0x10 [[Raw HTML-like data (eg. webkit)]]
}

enum Efl.Selection.Action
{
   [[Defines the kind of action associated with the drop data]]
   unknown, [[Action type is unknown]]
   copy, [[Copy the data]]
   move, [[Move the data]]
   private, [[Private action type]]
   ask, [[Ask the user what to do]]
   list, [[List the data]]
   link, [[Link the data]]
   description [[Describe the data]]
}

struct Efl.Selection.Data
{
   [[Structure holding the info about selected data]]
   x: int; [[The coordinates of the drop (DND operations only)]]
   y: int; [[The coordinates of the drop (DND operations only)]]
   format: Efl.Selection.Format; [[The format of the selection]]
   //data: Eina.Slice;
   data: void_ptr; [[The selection data, type determined by format member]]
   //len: uint; [[The length of the selection data]]
   len: int; [[The length of the selection data]]
   action: Efl.Selection.Action; [[The action to perform with the data @since 1.8]]
   //hovered_item: Efl.Object; [[item under the drag position. It is only available for container (CHECKING]]
   item: Efl.Object; [[item under the drag position. It is only available for container (CHECKING]]
}

function Efl.Selection.Data_Ready { //FIXME: promise
   [[Function pointer for getting selection]]
   params {
      @in obj: ptr(Eo); //CHECKING
      @in seldata: ptr(Efl.Selection.Data);
   }
};

struct Efl.Selection.Changed
{
   type: Efl.Selection.Type; [[The selection type]]
   seat: int; [[The seat on which the selection changed, or NULL for "default"]]
   display: void_ptr; [[The display connection object, NULL under X11]]
   exist: bool; [[EINA_TRUE if the selection has an owner]]
}*/

mixin Efl.Selection {
   [[Efl Copy and Paste class]]
   //legacy_prefix: elm_cnp;
   //eo_prefix: efl_selection;
   //data: Efl_Selection_Data_Priv;
   data: null;
   methods {
      selection_set {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            @in format: Efl.Selection.Format; [[Selection Format]]
            @in data: Eina.Slice;
            ////@in buf: const(void_ptr);
            ///@in len: int; [[The buffer's length.]]
            //@in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
            @in seat: uint @optional;[[Specified seat for multiple seats case.]]
         }
      }
      selection_get {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            @in format: Efl.Selection.Format; [[Selection Format]]
            @in data_func: Efl.Selection.Data_Ready; [[Data ready function pointer]]
            //@in seat: Efl.Input.Device @optional;[[Specified seat for multiple seats case.]]
            @in seat: uint @optional;[[Specified seat for multiple seats case.]]
         }
      }
      selection_clear {
         params {
            @in type: Efl.Selection.Type; [[Selection Type]]
            //@in seat: Efl.Input.Device @optional; [[Specified seat for multiple seats case.]]
            @in seat: uint @optional; [[Specified seat for multiple seats case.]]
         }
      }
      //selection_has { //change to property selection_owner
      has_owner {
         params {
            //@in type: Efl.Selection.Type (Efl.Selection.Type.clipboard);
            @in seat: uint @optional; [[Specified seat for multiple seats case.]]
         }
         return: bool;
      }
   }
   implements {
   }
   events {
      selection,lost; [[Called when selection has lost]]
      selection,changed; [[Called when display server's selection has changed]]
   }
}
