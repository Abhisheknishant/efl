/* FIXME: make abstract. */
class Ecore.Con.Server (Ecore.Con) {
   eo_prefix: ecore_con_server_obj;
   properties {
      name {
         /*@
          * Retrieves the name of server.
          *
          * The name returned is the name used to connect on this server.
          */
         get {
         }
         values {
            const(char) *name; /*@ The name of the server. */
         }
      }
      client_limit {
         /*@
          * Sets a limit on the number of clients that can be handled concurrently
          * by the given server, and a policy on what to do if excess clients try to
          * connect.
          *
          *
          * Beware that if you set this once ecore is already running, you may
          * already have pending CLIENT_ADD events in your event queue.  Those
          * clients have already connected and will not be affected by this call.
          * Only clients subsequently trying to connect will be affected.
          */
         set {
         }
         get {
            legacy: null;
         }
         values {
            int client_limit; /*@ The maximum number of clients to handle concurrently.  -1 means unlimited (default). 0 effectively disables the server. */
            char reject_excess_clients; /*@ Set to 1 to automatically disconnect excess clients as soon as they connect if you are already handling client_limit clients.  Set to 0 (default) to just hold off on the "accept()" system call until the number of active clients drops. This causes the kernel to queue up to 4096 connections (or your kernel's limit, whichever is lower). */
         }
      }
      /* FIXME: Should this return an iterator? */
      clients {
         /*@
          * Retrieves the current list of clients.
          *
          *
          * Each node in the returned list points to an @ref Ecore_Con_Client. This list
          * cannot be modified or freed. It can also change if new clients are connected
          * or disconnected, and will become invalid when the server is deleted/freed.
          */
         get {
         }
         values {
            const(Eina_List <const(Ecore.Con.Client) *>) *clients; /*@ The list of clients on this server. */
         }
      }
   }
   implements {
      Eo.Base.destructor;
      Ecore.Con.ip.get;
      Ecore.Con.uptime.get;
      Ecore.Con.port.get;
      Ecore.Con.fd.get;
      Ecore.Con.connected.get;
      Ecore.Con.timeout.set;
      Ecore.Con.timeout.get;
      Ecore.Con.flush;
      Ecore.Con.send;
   }
}
