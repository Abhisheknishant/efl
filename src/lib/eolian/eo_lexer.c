
#line 1 "lib/eolian/eo_lexer.rl"
#include <stdio.h>
#include <stdlib.h>
#include <Eina.h>

#include "Eolian.h"
#
#include "eo_lexer.h"
#include "eolian_database.h"

static int _eo_tokenizer_log_dom = -1;
#ifdef CRITICAL
#undef CRITICAL
#endif
#define CRITICAL(...) EINA_LOG_DOM_CRIT(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef ERR
#undef ERR
#endif
#define ERR(...) EINA_LOG_DOM_ERR(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef WRN
#undef WRN
#endif
#define WRN(...) EINA_LOG_DOM_WARN(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef INF
#undef INF
#endif
#define INF(...) EINA_LOG_DOM_INFO(_eo_tokenizer_log_dom, __VA_ARGS__)

#ifdef DBG
#undef DBG
#endif
#define DBG(...) EINA_LOG_DOM_DBG(_eo_tokenizer_log_dom, __VA_ARGS__)

static int _init_counter = 0;

int
eo_tokenizer_init()
{
   if (!_init_counter)
     {
        eina_init();
        eina_log_color_disable_set(EINA_FALSE);
        _eo_tokenizer_log_dom = eina_log_domain_register("eo_toknz", EINA_COLOR_CYAN);
     }
   return _init_counter++;
}

int
eo_tokenizer_shutdown()
{
   if (_init_counter <= 0) return 0;
   _init_counter--;
   if (!_init_counter)
     {
        eina_log_domain_unregister(_eo_tokenizer_log_dom);
        _eo_tokenizer_log_dom = -1;
        eina_shutdown();
     }
   return _init_counter;
}

static void
_eo_tokenizer_abort(Eo_Tokenizer *toknz,
                    const char *file, const char* fct, int line,
                    const char *fmt, ...)
{
   va_list ap;
   va_start (ap, fmt);
   eina_log_vprint(_eo_tokenizer_log_dom, EINA_LOG_LEVEL_ERR,
                   file, fct, line, fmt, ap);
   va_end(ap);
   fprintf(stderr, "File:%s\n toknz[%d] n:%d l:%d p:%d pe:%d ts:%s te:%s act:%d\n",
          toknz->source,
          toknz->cs, toknz->current_nesting, toknz->current_line,
          (int)(toknz->p - toknz->buf), (int)(toknz->pe - toknz->buf),
          toknz->ts, toknz->te, toknz->act);
   exit(EXIT_FAILURE);
}
#define ABORT(toknz, ...) \
   _eo_tokenizer_abort(toknz, __FILE__, __FUNCTION__, __LINE__, __VA_ARGS__);

static void _eo_tokenizer_normalize_buf(char *buf)
{
   int c;
   char *s, *d;
   Eina_Bool in_space = EINA_TRUE;
   Eina_Bool in_newline = EINA_FALSE;

   /* ' '+ -> ' '
    * '\n' ' '* '*' ' '* -> '\n'
    */
   for (s = buf, d = buf; *s != '\0'; s++)
     {
        c = *s;
        *d = c;

        if (!in_space || (c != ' '))
          d++;

        if (c == ' ')
          in_space = EINA_TRUE;
        else
          in_space = EINA_FALSE;

        if (c == '\n')
          {
             in_newline = EINA_TRUE;
             in_space = EINA_TRUE;
          }
        else if (in_newline && c == '*' )
          {
             in_space = EINA_TRUE;
             in_newline = EINA_FALSE;
             d--;
          }
     }
   /* ' '+$ -> $ */
   d--;
   while (*d == ' ') d--;
   d++;
   if (d < buf) return;
   *d = '\0';
}

static const char*
_eo_tokenizer_token_get(Eo_Tokenizer *toknz, char *p)
{
   if (toknz->saved.tok == NULL) ABORT(toknz, "toknz->saved.tok is NULL");
   char d[BUFSIZE];
   int l = (p - toknz->saved.tok);
   memcpy(d, toknz->saved.tok, l);
   d[l] = '\0';
   _eo_tokenizer_normalize_buf(d);
   toknz->saved.tok = NULL;
   DBG("token : >%s<", d);
   return eina_stringshare_add(d);
}

static Eo_Class_Def*
_eo_tokenizer_class_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Class_Def *kls = calloc(1, sizeof(Eo_Class_Def));
   if (kls == NULL) ABORT(toknz, "calloc Eo_Class_Def failure");

   kls->name = _eo_tokenizer_token_get(toknz, p);

   return kls;
}

static Eo_Property_Def*
_eo_tokenizer_property_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Property_Def *prop = calloc(1, sizeof(Eo_Property_Def));
   if (prop == NULL) ABORT(toknz, "calloc Eo_Property_Def failure");

   prop->name = _eo_tokenizer_token_get(toknz, p);

   return prop;
}

static Eo_Method_Def*
_eo_tokenizer_method_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Method_Def *meth = calloc(1, sizeof(Eo_Method_Def));
   if (meth == NULL) ABORT(toknz, "calloc Eo_Method_Def failure");

   meth->name = _eo_tokenizer_token_get(toknz, p);

   return meth;
}

static Eo_Param_Def*
_eo_tokenizer_param_get(Eo_Tokenizer *toknz, char *p)
{
   char *s;

   Eo_Param_Def *param = calloc(1, sizeof(Eo_Param_Def));
   if (param == NULL) ABORT(toknz, "calloc Eo_Param_Def failure");

   /* The next code part tries to identify the different tags of the
      parameter.
      First, we set the ';' to '\0', to search only inside this section.
      We then strstr the different tags and if found, we update the internal
      flag and clear the zone of the text. In this way, during the
      determination of the type/variable, we will not be disturbed by the
      flags.
      We have to put back the ';' at the end.
    */
   *p = '\0';
   s = strstr(toknz->saved.tok, "@nonull");
   if (s)
     {
        param->nonull = EINA_TRUE;
        memset(s, ' ', 7);
     }
   s = strstr(toknz->saved.tok, "@own");
   if (s)
     {
        param->own = EINA_TRUE;
        memset(s, ' ', 4);
     }
   *p = ';';
   s = p - 1; /* Don't look at the character ';' */
   /* Remove any space between the param name and ';'/@nonull
    * This loop fixes the case where "char *name ;" becomes the type of the param.
    */
   while (*s == ' ') s--;
   for (; s >= toknz->saved.tok; s--)
     {
        if ((*s == ' ') || (*s == '*'))
          break;
     }

   if (s == toknz->saved.tok)
     ABORT(toknz, "wrong parameter: %s", _eo_tokenizer_token_get(toknz, p));
   s++;

   param->way = PARAM_IN;
   if (strncmp(toknz->saved.tok, "@in ", 3) == 0)
     {
        toknz->saved.tok += 3;
        param->way = PARAM_IN;
     }
   else if (strncmp(toknz->saved.tok, "@out ", 4) == 0)
     {
        toknz->saved.tok += 4;
        param->way = PARAM_OUT;
     }
   else if (strncmp(toknz->saved.tok, "@inout ", 6) == 0)
     {
        toknz->saved.tok += 6;
        param->way = PARAM_INOUT;
     }

   param->type = _eo_tokenizer_token_get(toknz, s);

   toknz->saved.tok = s;
   param->name = _eo_tokenizer_token_get(toknz, p);

   return param;
}

static Eo_Ret_Def*
_eo_tokenizer_return_get(Eo_Tokenizer *toknz, char *p)
{
   char *s;

   Eo_Ret_Def *ret = calloc(1, sizeof(Eo_Ret_Def));
   if (ret == NULL) ABORT(toknz, "calloc Eo_Ret_Def failure");

   *p = '\0';
   s = strstr(toknz->saved.tok, "@warn_unused");
   if (s)
     {
        ret->warn_unused = EINA_TRUE;
        memset(s, ' ', 12);
     }
   s = strstr(toknz->saved.tok, "@own");
   if (s)
     {
        ret->own = EINA_TRUE;
        memset(s, ' ', 4);
     }
   s = strchr(toknz->saved.tok, '(');
   if (s)
     {
        char *end = strchr(s, ')');
        if (!end)
           ABORT(toknz, "wrong syntax (missing ')'): %s",
                 _eo_tokenizer_token_get(toknz, p));
        /* Current values in s and end have to be changed to ' ' to not disturb the next steps (type extraction) */
        *s++ = ' ';
        while (*s == ' ') s++;
        *end-- = ' ';
        while (end > s && *end == ' ') end--;
        if (end < s)
           ABORT(toknz, "empty default return value: %s",
                 _eo_tokenizer_token_get(toknz, p));
        ret->dflt_ret_val = strndup(s, end - s + 1);
        memset(s, ' ', end - s + 1);
     }
   *p = ';';
   s = p - 1; /* Don't look at the character ';' */
   /* Remove any space between the param name and ';'
    * This loop fixes the case where "char *name ;" becomes the type of the param.
    */
   while (*s == ' ') s--;

   if (s == toknz->saved.tok)
     ABORT(toknz, "wrong parameter: %s", _eo_tokenizer_token_get(toknz, p));
   s++;

   ret->type = _eo_tokenizer_token_get(toknz, s);

   return ret;
}

static Eo_Accessor_Param*
_eo_tokenizer_accessor_param_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Accessor_Param *param = calloc(1, sizeof(Eo_Accessor_Param));
   if (param == NULL) ABORT(toknz, "calloc Eo_Accessor_Param failure");

   /* Remove the colon and spaces - we just need the param name */
   while (*p == ':') p--;
   while (*p == ' ') p--;
   param->name = _eo_tokenizer_token_get(toknz, p);

   return param;
}

static Eo_Accessor_Def *
_eo_tokenizer_accessor_get(Eo_Tokenizer *toknz, Eo_Accessor_Type type)
{
   Eo_Accessor_Def *accessor = calloc(1, sizeof(Eo_Accessor_Def));
   if (accessor == NULL) ABORT(toknz, "calloc Eo_Accessor_Def failure");

   accessor->type = type;

   return accessor;
}

static Eo_Event_Def*
_eo_tokenizer_event_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Event_Def *sgn = calloc(1, sizeof(Eo_Event_Def));
   if (sgn == NULL) ABORT(toknz, "calloc Eo_Event_Def failure");

   sgn->name = _eo_tokenizer_token_get(toknz, p);

   return sgn;
}

static Eo_Implement_Def*
_eo_tokenizer_implement_get(Eo_Tokenizer *toknz, char *p)
{
   Eo_Implement_Def *impl = calloc(1, sizeof(Eo_Implement_Def));
   if (impl == NULL) ABORT(toknz, "calloc Eo_Implement_Def failure");

   impl->meth_name = _eo_tokenizer_token_get(toknz, p);

   return impl;
}


#line 423 "lib/eolian/eo_lexer.rl"



#line 355 "lib/eolian/eo_lexer.c"
static const char _eo_tokenizer_actions[] = {
	0, 1, 0, 1, 2, 1, 6, 1, 
	10, 1, 15, 1, 16, 1, 17, 1, 
	18, 1, 19, 1, 20, 1, 21, 1, 
	22, 1, 23, 1, 24, 1, 25, 1, 
	26, 1, 27, 1, 28, 1, 29, 1, 
	30, 1, 31, 1, 32, 1, 33, 1, 
	34, 1, 35, 1, 36, 1, 37, 1, 
	38, 1, 39, 1, 40, 1, 43, 1, 
	44, 1, 45, 1, 46, 1, 47, 1, 
	48, 1, 49, 1, 50, 1, 51, 1, 
	52, 1, 53, 1, 54, 1, 55, 1, 
	56, 1, 57, 1, 58, 1, 59, 1, 
	60, 1, 61, 1, 62, 1, 63, 1, 
	64, 1, 65, 1, 66, 1, 67, 1, 
	68, 1, 69, 1, 70, 1, 71, 1, 
	72, 1, 73, 1, 74, 1, 75, 1, 
	76, 1, 77, 1, 78, 1, 79, 1, 
	80, 1, 81, 1, 84, 1, 85, 1, 
	86, 1, 87, 1, 88, 1, 89, 1, 
	90, 1, 91, 1, 92, 1, 93, 1, 
	94, 1, 95, 1, 96, 1, 97, 1, 
	98, 1, 99, 1, 100, 1, 101, 1, 
	102, 1, 103, 1, 104, 1, 105, 1, 
	106, 1, 107, 1, 108, 1, 109, 1, 
	110, 1, 111, 1, 112, 1, 113, 1, 
	114, 1, 115, 1, 116, 1, 117, 1, 
	118, 1, 119, 1, 120, 1, 121, 1, 
	122, 1, 123, 1, 124, 2, 0, 40, 
	2, 0, 51, 2, 0, 60, 2, 0, 
	71, 2, 0, 80, 2, 0, 92, 2, 
	0, 101, 2, 0, 119, 2, 4, 46, 
	2, 5, 41, 2, 6, 2, 2, 7, 
	42, 2, 8, 55, 2, 10, 0, 2, 
	10, 72, 2, 12, 87, 2, 13, 82, 
	2, 14, 83, 2, 15, 0, 2, 15, 
	93, 2, 16, 0, 2, 17, 0, 2, 
	17, 120, 2, 18, 0, 2, 19, 0, 
	2, 19, 2, 2, 23, 0, 2, 24, 
	0, 2, 24, 2, 2, 25, 0, 2, 
	27, 0, 2, 28, 0, 2, 28, 2, 
	2, 35, 0, 2, 35, 120, 2, 38, 
	1, 2, 38, 2, 2, 38, 3, 2, 
	38, 9, 2, 38, 11
};

static const short _eo_tokenizer_key_offsets[] = {
	0, 2, 5, 6, 7, 8, 9, 10, 
	11, 12, 15, 22, 29, 44, 48, 56, 
	61, 65, 72, 84, 89, 96, 97, 98, 
	99, 102, 103, 104, 105, 106, 107, 108, 
	109, 112, 113, 114, 115, 118, 121, 123, 
	126, 137, 139, 142, 143, 154, 158, 165, 
	172, 184, 196, 208, 220, 232, 243, 251, 
	258, 266, 278, 290, 302, 314, 325, 333, 
	347, 362, 366, 367, 368, 378, 380, 383, 
	385, 388, 389, 401, 405, 406, 407, 417, 
	419, 422, 424, 427, 428, 429, 433, 434, 
	435, 439, 440, 444, 445, 446, 447, 448, 
	452, 454, 457, 458, 469, 473, 476, 478, 
	481, 492, 494, 497, 498, 499, 500, 501, 
	502, 503, 504, 505, 506, 509, 516, 523, 
	531, 532, 533, 534, 535, 539, 540, 541, 
	542, 543, 546, 553, 567, 582, 586, 587, 
	588, 598, 600, 603, 605, 608, 609, 620, 
	624, 627, 629, 632, 643, 645, 648, 649, 
	650, 651, 652, 653, 654, 655, 656, 657, 
	658, 659, 663, 664, 665, 669, 676, 683, 
	691, 692, 693, 694, 695, 696, 697, 698, 
	699, 700, 704, 705, 706, 707, 708, 709, 
	710, 711, 715, 722, 729, 737, 738, 739, 
	740, 741, 745, 753, 761, 773, 777, 789, 
	790, 791, 801, 803, 806, 814, 815, 816, 
	817, 818, 819, 820, 821, 822, 826, 834, 
	842, 855, 860, 864, 865, 866, 867, 868, 
	869, 881, 886, 890, 899, 903, 904, 905, 
	906, 907, 908, 912, 921, 928, 935, 946, 
	950, 964, 974, 981, 993, 998, 1004, 1009, 
	1010, 1011, 1012, 1013, 1014, 1017, 1024, 1031, 
	1039, 1040, 1044, 1051, 1059, 1063, 1068, 1069, 
	1070, 1080, 1082, 1085, 1095, 1107, 1114, 1126, 
	1127, 1128, 1129, 1130, 1131, 1132, 1133, 1134, 
	1135, 1136, 1137, 1138, 1142, 1149, 1156, 1164, 
	1165, 1166, 1167, 1168, 1169, 1173, 1174, 1175, 
	1176, 1177, 1178, 1179, 1180, 1181, 1185, 1193, 
	1196, 1198, 1199, 1200, 1201, 1202, 1213, 1216, 
	1218, 1225, 1233, 1241, 1245, 1245, 1246, 1255, 
	1258, 1260, 1271, 1275, 1275, 1276, 1285, 1288, 
	1290, 1291, 1292, 1293, 1294, 1295, 1304, 1307, 
	1309, 1316, 1317, 1326, 1329, 1331, 1332, 1333, 
	1334, 1335, 1339, 1339, 1340, 1349, 1352, 1354, 
	1361, 1362, 1374, 1377, 1379, 1380, 1382, 1385, 
	1387, 1390, 1391, 1392, 1393, 1394, 1397, 1398, 
	1399
};

static const char _eo_tokenizer_trans_keys[] = {
	10, 42, 10, 42, 47, 10, 115, 116, 
	114, 97, 99, 116, 9, 13, 32, 9, 
	13, 32, 65, 90, 97, 122, 95, 48, 
	57, 65, 90, 97, 122, 9, 10, 13, 
	32, 40, 95, 123, 0, 31, 48, 57, 
	65, 90, 97, 122, 10, 123, 0, 32, 
	9, 10, 13, 32, 40, 123, 0, 31, 
	41, 65, 90, 97, 122, 10, 123, 0, 
	32, 95, 48, 57, 65, 90, 97, 122, 
	10, 41, 44, 95, 0, 32, 48, 57, 
	65, 90, 97, 122, 10, 41, 44, 0, 
	32, 10, 0, 32, 65, 90, 97, 122, 
	97, 115, 115, 9, 13, 32, 116, 101, 
	114, 102, 97, 99, 101, 9, 13, 32, 
	120, 105, 110, 9, 13, 32, 10, 42, 
	64, 10, 42, 10, 42, 47, 10, 42, 
	95, 0, 32, 48, 57, 64, 90, 97, 
	122, 10, 42, 10, 42, 47, 10, 9, 
	13, 32, 58, 95, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 9, 13, 
	32, 65, 90, 97, 122, 9, 13, 32, 
	65, 90, 97, 122, 9, 13, 32, 44, 
	59, 95, 48, 57, 65, 90, 97, 122, 
	9, 13, 32, 58, 95, 103, 48, 57, 
	65, 90, 97, 122, 9, 13, 32, 58, 
	95, 97, 48, 57, 65, 90, 98, 122, 
	9, 13, 32, 58, 95, 99, 48, 57, 
	65, 90, 97, 122, 9, 13, 32, 58, 
	95, 121, 48, 57, 65, 90, 97, 122, 
	9, 13, 32, 58, 95, 48, 57, 65, 
	90, 97, 122, 9, 13, 32, 58, 65, 
	90, 97, 122, 95, 48, 57, 65, 90, 
	97, 122, 59, 95, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 95, 116, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 95, 117, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 95, 114, 
	48, 57, 65, 90, 97, 122, 9, 13, 
	32, 58, 95, 110, 48, 57, 65, 90, 
	97, 122, 9, 13, 32, 58, 95, 48, 
	57, 65, 90, 97, 122, 9, 13, 32, 
	58, 65, 90, 97, 122, 9, 13, 32, 
	95, 40, 42, 45, 46, 48, 57, 64, 
	90, 97, 122, 9, 13, 32, 59, 95, 
	40, 42, 45, 46, 48, 57, 64, 90, 
	97, 122, 9, 13, 32, 47, 42, 64, 
	10, 95, 0, 32, 48, 57, 64, 90, 
	97, 122, 10, 42, 10, 42, 47, 10, 
	42, 10, 42, 47, 10, 9, 13, 32, 
	42, 59, 95, 48, 57, 64, 90, 97, 
	122, 9, 13, 32, 47, 42, 64, 10, 
	95, 0, 32, 48, 57, 64, 90, 97, 
	122, 10, 42, 10, 42, 47, 10, 42, 
	10, 42, 47, 10, 116, 10, 123, 0, 
	32, 121, 115, 10, 123, 0, 32, 116, 
	10, 123, 0, 32, 108, 117, 101, 115, 
	10, 123, 0, 32, 10, 42, 10, 42, 
	47, 10, 10, 95, 123, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 123, 0, 
	32, 10, 42, 64, 10, 42, 10, 42, 
	47, 10, 42, 95, 0, 32, 48, 57, 
	64, 90, 97, 122, 10, 42, 10, 42, 
	47, 10, 110, 115, 116, 59, 103, 97, 
	99, 121, 9, 13, 32, 9, 13, 32, 
	65, 90, 97, 122, 95, 48, 57, 65, 
	90, 97, 122, 59, 95, 48, 57, 65, 
	90, 97, 122, 114, 97, 109, 115, 10, 
	123, 0, 32, 116, 117, 114, 110, 9, 
	13, 32, 9, 13, 32, 65, 90, 97, 
	122, 9, 13, 32, 95, 40, 42, 45, 
	46, 48, 57, 64, 90, 97, 122, 9, 
	13, 32, 59, 95, 40, 42, 45, 46, 
	48, 57, 64, 90, 97, 122, 9, 13, 
	32, 47, 42, 64, 10, 95, 0, 32, 
	48, 57, 64, 90, 97, 122, 10, 42, 
	10, 42, 47, 10, 42, 10, 42, 47, 
	10, 10, 95, 123, 0, 32, 48, 57, 
	65, 90, 97, 122, 10, 123, 0, 32, 
	10, 42, 64, 10, 42, 10, 42, 47, 
	10, 42, 95, 0, 32, 48, 57, 64, 
	90, 97, 122, 10, 42, 10, 42, 47, 
	10, 110, 115, 116, 114, 117, 99, 116, 
	111, 114, 115, 10, 123, 0, 32, 116, 
	97, 10, 58, 0, 32, 10, 0, 32, 
	65, 90, 97, 122, 95, 48, 57, 65, 
	90, 97, 122, 59, 95, 48, 57, 65, 
	90, 97, 122, 115, 116, 114, 117, 99, 
	116, 111, 114, 115, 10, 123, 0, 32, 
	95, 112, 114, 101, 102, 105, 120, 10, 
	58, 0, 32, 10, 0, 32, 65, 90, 
	97, 122, 95, 48, 57, 65, 90, 97, 
	122, 59, 95, 48, 57, 65, 90, 97, 
	122, 101, 110, 116, 115, 10, 123, 0, 
	32, 10, 125, 0, 32, 65, 90, 97, 
	122, 44, 95, 48, 57, 65, 90, 97, 
	122, 10, 44, 59, 95, 0, 32, 48, 
	57, 65, 90, 97, 122, 10, 59, 0, 
	32, 9, 10, 13, 32, 47, 125, 0, 
	31, 65, 90, 97, 122, 42, 64, 10, 
	95, 0, 32, 48, 57, 64, 90, 97, 
	122, 10, 42, 10, 42, 47, 10, 125, 
	0, 32, 65, 90, 97, 122, 112, 108, 
	101, 109, 101, 110, 116, 115, 10, 123, 
	0, 32, 10, 125, 0, 32, 65, 90, 
	97, 122, 58, 95, 48, 57, 65, 90, 
	97, 122, 10, 58, 59, 95, 123, 0, 
	32, 48, 57, 65, 90, 97, 122, 10, 
	59, 123, 0, 32, 10, 108, 0, 32, 
	101, 103, 97, 99, 121, 9, 10, 13, 
	32, 59, 123, 0, 31, 65, 90, 97, 
	122, 10, 59, 123, 0, 32, 10, 125, 
	0, 32, 10, 59, 125, 0, 32, 65, 
	90, 97, 122, 10, 112, 0, 32, 97, 
	114, 97, 109, 115, 10, 123, 0, 32, 
	10, 58, 59, 0, 32, 65, 90, 97, 
	122, 9, 13, 32, 65, 90, 97, 122, 
	95, 48, 57, 65, 90, 97, 122, 10, 
	59, 95, 0, 32, 48, 57, 65, 90, 
	97, 122, 10, 59, 0, 32, 9, 10, 
	13, 32, 47, 58, 59, 125, 0, 31, 
	65, 90, 97, 122, 10, 58, 59, 125, 
	0, 32, 65, 90, 97, 122, 95, 48, 
	57, 65, 90, 97, 122, 9, 13, 32, 
	58, 59, 95, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 58, 59, 10, 59, 
	114, 125, 0, 32, 10, 114, 125, 0, 
	32, 101, 116, 117, 114, 110, 9, 13, 
	32, 9, 13, 32, 65, 90, 97, 122, 
	95, 48, 57, 65, 90, 97, 122, 58, 
	95, 48, 57, 65, 90, 97, 122, 58, 
	65, 90, 97, 122, 95, 48, 57, 65, 
	90, 97, 122, 59, 95, 48, 57, 65, 
	90, 97, 122, 10, 125, 0, 32, 10, 
	59, 125, 0, 32, 42, 64, 10, 95, 
	0, 32, 48, 57, 64, 90, 97, 122, 
	10, 42, 10, 42, 47, 10, 58, 59, 
	125, 0, 32, 65, 90, 97, 122, 9, 
	10, 13, 32, 59, 123, 0, 31, 65, 
	90, 97, 122, 95, 48, 57, 65, 90, 
	97, 122, 10, 59, 95, 123, 0, 32, 
	48, 57, 65, 90, 97, 122, 58, 103, 
	97, 99, 121, 95, 112, 114, 101, 102, 
	105, 120, 10, 58, 0, 32, 10, 0, 
	32, 65, 90, 97, 122, 95, 48, 57, 
	65, 90, 97, 122, 59, 95, 48, 57, 
	65, 90, 97, 122, 116, 104, 111, 100, 
	115, 10, 123, 0, 32, 111, 112, 101, 
	114, 116, 105, 101, 115, 10, 123, 0, 
	32, 10, 47, 97, 99, 105, 109, 0, 
	32, 10, 0, 32, 42, 47, 98, 108, 
	110, 105, 10, 47, 108, 114, 125, 0, 
	32, 65, 90, 97, 122, 10, 0, 32, 
	42, 47, 95, 48, 57, 65, 90, 97, 
	122, 95, 101, 48, 57, 65, 90, 97, 
	122, 95, 101, 48, 57, 65, 90, 97, 
	122, 9, 13, 32, 47, 59, 10, 47, 
	125, 0, 32, 64, 90, 97, 122, 10, 
	0, 32, 42, 47, 9, 13, 32, 42, 
	95, 48, 57, 64, 90, 97, 122, 9, 
	13, 32, 47, 59, 10, 47, 103, 107, 
	115, 118, 125, 0, 32, 10, 0, 32, 
	42, 47, 101, 101, 101, 97, 59, 10, 
	47, 125, 0, 32, 65, 90, 97, 122, 
	10, 0, 32, 42, 47, 95, 48, 57, 
	65, 90, 97, 122, 59, 10, 47, 99, 
	108, 112, 114, 125, 0, 32, 10, 0, 
	32, 42, 47, 111, 101, 97, 101, 9, 
	13, 32, 47, 59, 10, 47, 125, 0, 
	32, 65, 90, 97, 122, 10, 0, 32, 
	42, 47, 95, 48, 57, 65, 90, 97, 
	122, 59, 10, 47, 99, 100, 101, 105, 
	108, 109, 112, 125, 0, 32, 10, 0, 
	32, 42, 47, 111, 97, 101, 10, 0, 
	32, 111, 118, 10, 0, 32, 59, 109, 
	59, 101, 10, 0, 32, 101, 114, 59, 
	0
};

static const char _eo_tokenizer_single_lengths[] = {
	2, 3, 1, 1, 1, 1, 1, 1, 
	1, 3, 3, 1, 7, 2, 6, 1, 
	2, 1, 4, 3, 1, 1, 1, 1, 
	3, 1, 1, 1, 1, 1, 1, 1, 
	3, 1, 1, 1, 3, 3, 2, 3, 
	3, 2, 3, 1, 5, 4, 3, 3, 
	6, 6, 6, 6, 6, 5, 4, 1, 
	2, 6, 6, 6, 6, 5, 4, 4, 
	5, 4, 1, 1, 2, 2, 3, 2, 
	3, 1, 6, 4, 1, 1, 2, 2, 
	3, 2, 3, 1, 1, 2, 1, 1, 
	2, 1, 2, 1, 1, 1, 1, 2, 
	2, 3, 1, 3, 2, 3, 2, 3, 
	3, 2, 3, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 3, 3, 1, 2, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 3, 3, 4, 5, 4, 1, 1, 
	2, 2, 3, 2, 3, 1, 3, 2, 
	3, 2, 3, 3, 2, 3, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 2, 1, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 2, 1, 1, 1, 
	1, 2, 2, 2, 4, 2, 6, 1, 
	1, 2, 2, 3, 2, 1, 1, 1, 
	1, 1, 1, 1, 1, 2, 2, 2, 
	5, 3, 2, 1, 1, 1, 1, 1, 
	6, 3, 2, 3, 2, 1, 1, 1, 
	1, 1, 2, 3, 3, 1, 3, 2, 
	8, 4, 1, 6, 5, 4, 3, 1, 
	1, 1, 1, 1, 3, 3, 1, 2, 
	1, 0, 1, 2, 2, 3, 1, 1, 
	2, 2, 3, 4, 6, 1, 4, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 2, 1, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 1, 1, 1, 1, 2, 6, 1, 
	2, 1, 1, 1, 1, 5, 1, 2, 
	1, 2, 2, 4, 0, 1, 3, 1, 
	2, 5, 4, 0, 1, 7, 1, 2, 
	1, 1, 1, 1, 1, 3, 1, 2, 
	1, 1, 7, 1, 2, 1, 1, 1, 
	1, 4, 0, 1, 3, 1, 2, 1, 
	1, 10, 1, 2, 1, 2, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1
};

static const char _eo_tokenizer_range_lengths[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 2, 3, 4, 1, 1, 2, 
	1, 3, 4, 1, 3, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	4, 0, 0, 0, 3, 0, 2, 2, 
	3, 3, 3, 3, 3, 3, 2, 3, 
	3, 3, 3, 3, 3, 3, 2, 5, 
	5, 0, 0, 0, 4, 0, 0, 0, 
	0, 0, 3, 0, 0, 0, 4, 0, 
	0, 0, 0, 0, 0, 1, 0, 0, 
	1, 0, 1, 0, 0, 0, 0, 1, 
	0, 0, 0, 4, 1, 0, 0, 0, 
	4, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 2, 3, 3, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 2, 5, 5, 0, 0, 0, 
	4, 0, 0, 0, 0, 0, 4, 1, 
	0, 0, 0, 4, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 1, 3, 3, 3, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 0, 0, 0, 0, 0, 
	0, 1, 3, 3, 3, 0, 0, 0, 
	0, 1, 3, 3, 4, 1, 3, 0, 
	0, 4, 0, 0, 3, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 3, 3, 
	4, 1, 1, 0, 0, 0, 0, 0, 
	3, 1, 1, 3, 1, 0, 0, 0, 
	0, 0, 1, 3, 2, 3, 4, 1, 
	3, 3, 3, 3, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 2, 3, 3, 
	0, 2, 3, 3, 1, 1, 0, 0, 
	4, 0, 0, 3, 3, 3, 4, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 3, 3, 3, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	0, 0, 0, 0, 0, 3, 1, 0, 
	3, 3, 3, 0, 0, 0, 3, 1, 
	0, 3, 0, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 3, 1, 0, 
	3, 0, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 3, 1, 0, 3, 
	0, 1, 1, 0, 0, 0, 1, 0, 
	1, 0, 0, 0, 0, 1, 0, 0, 
	0
};

static const short _eo_tokenizer_index_offsets[] = {
	0, 3, 7, 9, 11, 13, 15, 17, 
	19, 21, 25, 31, 36, 48, 52, 60, 
	64, 68, 73, 82, 87, 92, 94, 96, 
	98, 102, 104, 106, 108, 110, 112, 114, 
	116, 120, 122, 124, 126, 130, 134, 137, 
	141, 149, 152, 156, 158, 167, 172, 178, 
	184, 194, 204, 214, 224, 234, 243, 250, 
	255, 261, 271, 281, 291, 301, 310, 317, 
	327, 338, 343, 345, 347, 354, 357, 361, 
	364, 368, 370, 380, 385, 387, 389, 396, 
	399, 403, 406, 410, 412, 414, 418, 420, 
	422, 426, 428, 432, 434, 436, 438, 440, 
	444, 447, 451, 453, 461, 465, 469, 472, 
	476, 484, 487, 491, 493, 495, 497, 499, 
	501, 503, 505, 507, 509, 513, 519, 524, 
	530, 532, 534, 536, 538, 542, 544, 546, 
	548, 550, 554, 560, 570, 581, 586, 588, 
	590, 597, 600, 604, 607, 611, 613, 621, 
	625, 629, 632, 636, 644, 647, 651, 653, 
	655, 657, 659, 661, 663, 665, 667, 669, 
	671, 673, 677, 679, 681, 685, 690, 695, 
	701, 703, 705, 707, 709, 711, 713, 715, 
	717, 719, 723, 725, 727, 729, 731, 733, 
	735, 737, 741, 746, 751, 757, 759, 761, 
	763, 765, 769, 775, 781, 790, 794, 804, 
	806, 808, 815, 818, 822, 828, 830, 832, 
	834, 836, 838, 840, 842, 844, 848, 854, 
	860, 870, 875, 879, 881, 883, 885, 887, 
	889, 899, 904, 908, 915, 919, 921, 923, 
	925, 927, 929, 933, 940, 946, 951, 959, 
	963, 975, 983, 988, 998, 1004, 1010, 1015, 
	1017, 1019, 1021, 1023, 1025, 1029, 1035, 1040, 
	1046, 1048, 1051, 1056, 1062, 1066, 1071, 1073, 
	1075, 1082, 1085, 1089, 1097, 1107, 1112, 1121, 
	1123, 1125, 1127, 1129, 1131, 1133, 1135, 1137, 
	1139, 1141, 1143, 1145, 1149, 1154, 1159, 1165, 
	1167, 1169, 1171, 1173, 1175, 1179, 1181, 1183, 
	1185, 1187, 1189, 1191, 1193, 1195, 1199, 1207, 
	1210, 1213, 1215, 1217, 1219, 1221, 1230, 1233, 
	1236, 1241, 1247, 1253, 1258, 1259, 1261, 1268, 
	1271, 1274, 1283, 1288, 1289, 1291, 1300, 1303, 
	1306, 1308, 1310, 1312, 1314, 1316, 1323, 1326, 
	1329, 1334, 1336, 1345, 1348, 1351, 1353, 1355, 
	1357, 1359, 1364, 1365, 1367, 1374, 1377, 1380, 
	1385, 1387, 1399, 1402, 1405, 1407, 1410, 1413, 
	1416, 1419, 1421, 1423, 1425, 1427, 1430, 1432, 
	1434
};

static const short _eo_tokenizer_indicies[] = {
	2, 3, 1, 2, 3, 4, 1, 6, 
	5, 7, 0, 8, 0, 9, 0, 10, 
	0, 11, 0, 12, 0, 13, 13, 13, 
	0, 14, 14, 14, 15, 15, 0, 16, 
	16, 16, 16, 0, 18, 19, 18, 18, 
	20, 16, 21, 17, 16, 16, 16, 0, 
	23, 24, 22, 0, 25, 23, 25, 25, 
	26, 24, 22, 0, 27, 28, 28, 0, 
	30, 31, 29, 0, 32, 32, 32, 32, 
	0, 34, 35, 36, 32, 33, 32, 32, 
	32, 0, 38, 27, 39, 37, 0, 40, 
	39, 28, 28, 0, 41, 0, 42, 0, 
	43, 0, 44, 44, 44, 0, 45, 0, 
	46, 0, 47, 0, 48, 0, 49, 0, 
	50, 0, 51, 0, 52, 52, 52, 0, 
	53, 0, 54, 0, 55, 0, 56, 56, 
	56, 0, 59, 60, 61, 58, 59, 60, 
	58, 59, 60, 62, 58, 63, 60, 64, 
	61, 64, 64, 64, 58, 66, 67, 65, 
	66, 67, 68, 65, 70, 69, 71, 71, 
	71, 73, 72, 72, 72, 72, 57, 71, 
	71, 71, 73, 57, 74, 74, 74, 75, 
	75, 57, 76, 76, 76, 77, 77, 57, 
	78, 78, 78, 78, 79, 78, 78, 78, 
	78, 57, 71, 71, 71, 73, 72, 80, 
	72, 72, 72, 57, 71, 71, 71, 73, 
	72, 81, 72, 72, 72, 57, 71, 71, 
	71, 73, 72, 82, 72, 72, 72, 57, 
	71, 71, 71, 73, 72, 83, 72, 72, 
	72, 57, 84, 84, 84, 73, 72, 72, 
	72, 72, 57, 84, 84, 84, 73, 85, 
	85, 57, 86, 86, 86, 86, 57, 87, 
	86, 86, 86, 86, 57, 71, 71, 71, 
	73, 72, 88, 72, 72, 72, 57, 71, 
	71, 71, 73, 72, 89, 72, 72, 72, 
	57, 71, 71, 71, 73, 72, 90, 72, 
	72, 72, 57, 71, 71, 71, 73, 72, 
	91, 72, 72, 72, 57, 92, 92, 92, 
	73, 72, 72, 72, 72, 57, 92, 92, 
	92, 73, 93, 93, 57, 94, 94, 94, 
	94, 94, 94, 94, 94, 94, 57, 94, 
	94, 94, 95, 94, 94, 94, 94, 94, 
	94, 57, 97, 97, 97, 98, 96, 99, 
	96, 100, 96, 101, 102, 100, 102, 102, 
	102, 96, 104, 105, 103, 104, 105, 106, 
	103, 109, 110, 108, 109, 110, 111, 108, 
	113, 112, 114, 114, 114, 114, 115, 114, 
	114, 114, 114, 107, 117, 117, 117, 118, 
	116, 119, 116, 120, 116, 121, 122, 120, 
	122, 122, 122, 116, 124, 125, 123, 124, 
	125, 126, 123, 129, 130, 128, 129, 130, 
	131, 128, 133, 132, 134, 127, 135, 136, 
	134, 127, 137, 127, 138, 127, 139, 140, 
	138, 127, 141, 127, 142, 143, 141, 127, 
	144, 127, 145, 127, 146, 127, 147, 127, 
	148, 149, 147, 127, 152, 153, 151, 152, 
	153, 154, 151, 156, 155, 158, 159, 160, 
	157, 159, 159, 159, 150, 162, 163, 161, 
	150, 166, 167, 168, 165, 166, 167, 165, 
	166, 167, 169, 165, 170, 167, 171, 168, 
	171, 171, 171, 165, 173, 174, 172, 173, 
	174, 175, 172, 177, 176, 178, 164, 179, 
	164, 180, 164, 181, 164, 182, 164, 183, 
	164, 184, 164, 185, 164, 186, 186, 186, 
	164, 186, 186, 186, 187, 187, 164, 188, 
	188, 188, 188, 164, 189, 188, 188, 188, 
	188, 164, 190, 164, 191, 164, 192, 164, 
	193, 164, 194, 195, 193, 164, 196, 164, 
	197, 164, 198, 164, 199, 164, 200, 200, 
	200, 164, 200, 200, 200, 201, 201, 164, 
	202, 202, 202, 202, 202, 202, 202, 202, 
	202, 164, 202, 202, 202, 203, 202, 202, 
	202, 202, 202, 202, 164, 205, 205, 205, 
	206, 204, 207, 204, 208, 204, 209, 210, 
	208, 210, 210, 210, 204, 212, 213, 211, 
	212, 213, 214, 211, 217, 218, 216, 217, 
	218, 219, 216, 221, 220, 223, 224, 225, 
	222, 224, 224, 224, 215, 227, 228, 226, 
	215, 231, 232, 233, 230, 231, 232, 230, 
	231, 232, 234, 230, 235, 232, 236, 233, 
	236, 236, 236, 230, 238, 239, 237, 238, 
	239, 240, 237, 242, 241, 243, 229, 244, 
	229, 245, 229, 246, 229, 247, 229, 248, 
	229, 249, 229, 250, 229, 251, 229, 252, 
	229, 253, 254, 252, 229, 255, 229, 256, 
	229, 257, 258, 256, 229, 259, 258, 260, 
	260, 229, 261, 261, 261, 261, 229, 262, 
	261, 261, 261, 261, 229, 263, 229, 264, 
	229, 265, 229, 266, 229, 267, 229, 268, 
	229, 269, 229, 270, 229, 271, 229, 272, 
	273, 271, 229, 274, 229, 275, 229, 276, 
	229, 277, 229, 278, 229, 279, 229, 280, 
	229, 281, 282, 280, 229, 283, 282, 284, 
	284, 229, 285, 285, 285, 285, 229, 286, 
	285, 285, 285, 285, 229, 287, 229, 288, 
	229, 289, 229, 290, 229, 291, 292, 290, 
	229, 293, 295, 292, 294, 294, 229, 296, 
	296, 296, 296, 296, 229, 298, 296, 299, 
	296, 297, 296, 296, 296, 229, 301, 302, 
	300, 229, 302, 293, 302, 302, 303, 295, 
	292, 294, 294, 229, 304, 229, 305, 229, 
	306, 307, 305, 307, 307, 307, 229, 309, 
	310, 308, 309, 310, 311, 308, 313, 315, 
	312, 314, 314, 229, 316, 229, 317, 229, 
	318, 229, 319, 229, 320, 229, 321, 229, 
	322, 229, 323, 229, 324, 325, 323, 229, 
	326, 328, 325, 327, 327, 229, 330, 329, 
	329, 329, 329, 229, 332, 330, 333, 329, 
	334, 331, 329, 329, 329, 229, 336, 325, 
	337, 335, 229, 338, 339, 337, 229, 340, 
	229, 341, 229, 342, 229, 343, 229, 344, 
	229, 346, 347, 346, 346, 348, 350, 345, 
	349, 349, 229, 352, 353, 354, 351, 229, 
	355, 356, 353, 229, 326, 325, 328, 325, 
	327, 327, 229, 357, 358, 354, 229, 359, 
	229, 360, 229, 361, 229, 362, 229, 363, 
	229, 364, 365, 363, 229, 366, 367, 368, 
	365, 369, 369, 229, 367, 367, 367, 370, 
	370, 229, 371, 371, 371, 371, 229, 373, 
	374, 371, 372, 371, 371, 371, 229, 376, 
	368, 375, 229, 368, 378, 368, 368, 379, 
	367, 368, 380, 377, 369, 369, 229, 378, 
	367, 368, 380, 377, 369, 369, 229, 381, 
	381, 381, 381, 229, 382, 382, 382, 383, 
	384, 381, 381, 381, 381, 229, 385, 385, 
	385, 367, 368, 229, 387, 386, 388, 389, 
	386, 229, 387, 388, 389, 386, 229, 390, 
	229, 391, 229, 392, 229, 393, 229, 394, 
	229, 395, 395, 395, 229, 395, 395, 395, 
	396, 396, 229, 397, 397, 397, 397, 229, 
	398, 397, 397, 397, 397, 229, 399, 229, 
	400, 400, 229, 401, 401, 401, 401, 229, 
	402, 401, 401, 401, 401, 229, 404, 389, 
	403, 229, 355, 353, 356, 353, 229, 405, 
	229, 406, 229, 407, 408, 406, 408, 408, 
	408, 229, 410, 411, 409, 410, 411, 412, 
	409, 414, 415, 416, 418, 413, 417, 417, 
	229, 419, 352, 419, 419, 353, 354, 351, 
	420, 420, 229, 421, 421, 421, 421, 229, 
	423, 424, 421, 425, 422, 421, 421, 421, 
	229, 329, 229, 426, 229, 427, 229, 428, 
	229, 429, 229, 430, 229, 431, 229, 432, 
	229, 433, 229, 434, 229, 435, 229, 436, 
	229, 437, 438, 436, 229, 439, 438, 440, 
	440, 229, 441, 441, 441, 441, 229, 442, 
	441, 441, 441, 441, 229, 443, 229, 444, 
	229, 445, 229, 446, 229, 447, 229, 448, 
	449, 447, 229, 450, 229, 451, 229, 452, 
	229, 453, 229, 454, 229, 455, 229, 456, 
	229, 457, 229, 458, 459, 457, 229, 462, 
	463, 464, 465, 466, 467, 461, 460, 462, 
	461, 468, 1, 5, 469, 470, 469, 471, 
	469, 472, 469, 473, 469, 476, 477, 479, 
	480, 481, 475, 478, 478, 474, 476, 475, 
	482, 484, 69, 483, 72, 72, 72, 72, 
	483, 72, 485, 72, 72, 72, 483, 72, 
	486, 72, 72, 72, 483, 97, 97, 97, 
	98, 487, 488, 490, 489, 493, 494, 496, 
	492, 495, 495, 491, 493, 492, 497, 108, 
	112, 498, 114, 114, 114, 114, 114, 114, 
	114, 114, 498, 117, 117, 117, 118, 499, 
	500, 502, 501, 505, 506, 507, 508, 509, 
	510, 511, 504, 503, 505, 504, 512, 128, 
	132, 513, 514, 513, 515, 513, 516, 513, 
	517, 513, 519, 518, 522, 523, 525, 521, 
	524, 524, 520, 522, 521, 526, 151, 155, 
	527, 159, 159, 159, 159, 527, 529, 528, 
	532, 533, 534, 535, 536, 537, 538, 531, 
	530, 532, 531, 539, 541, 176, 540, 542, 
	540, 543, 540, 544, 540, 545, 540, 205, 
	205, 205, 206, 546, 547, 549, 548, 552, 
	553, 555, 551, 554, 554, 550, 552, 551, 
	556, 216, 220, 557, 224, 224, 224, 224, 
	557, 559, 558, 562, 563, 564, 565, 566, 
	567, 568, 569, 570, 571, 561, 560, 562, 
	561, 572, 574, 241, 573, 575, 573, 576, 
	577, 573, 580, 579, 578, 581, 582, 573, 
	585, 584, 583, 587, 586, 588, 573, 590, 
	589, 591, 573, 594, 593, 592, 595, 573, 
	596, 573, 598, 597, 0
};

static const short _eo_tokenizer_trans_targs[] = {
	302, 0, 0, 1, 302, 2, 302, 4, 
	5, 6, 7, 8, 9, 10, 10, 11, 
	12, 13, 14, 13, 15, 302, 13, 13, 
	302, 14, 15, 16, 17, 13, 13, 302, 
	18, 19, 19, 16, 20, 19, 19, 20, 
	20, 22, 23, 24, 10, 26, 27, 28, 
	29, 30, 31, 32, 10, 34, 35, 36, 
	10, 309, 38, 38, 39, 40, 309, 40, 
	41, 41, 41, 42, 309, 43, 309, 45, 
	44, 46, 47, 48, 47, 48, 48, 309, 
	50, 51, 52, 53, 54, 55, 56, 309, 
	58, 59, 60, 61, 62, 63, 64, 315, 
	309, 65, 66, 67, 68, 68, 69, 69, 
	69, 70, 316, 318, 71, 71, 72, 318, 
	73, 318, 74, 322, 318, 75, 76, 77, 
	78, 78, 79, 79, 79, 80, 323, 325, 
	81, 81, 82, 325, 83, 325, 85, 85, 
	325, 87, 88, 88, 325, 90, 90, 325, 
	92, 93, 94, 95, 95, 325, 333, 96, 
	96, 97, 333, 98, 333, 100, 100, 99, 
	333, 100, 100, 333, 338, 102, 102, 103, 
	104, 338, 104, 105, 105, 105, 106, 338, 
	107, 338, 109, 110, 111, 338, 113, 114, 
	115, 116, 117, 118, 119, 338, 121, 122, 
	123, 124, 124, 338, 126, 127, 128, 129, 
	130, 131, 132, 345, 338, 133, 134, 135, 
	136, 136, 137, 137, 137, 138, 346, 348, 
	139, 139, 140, 348, 141, 348, 143, 143, 
	142, 348, 143, 143, 348, 353, 145, 145, 
	146, 147, 353, 147, 148, 148, 148, 149, 
	353, 150, 353, 152, 153, 154, 155, 156, 
	157, 158, 159, 160, 161, 161, 353, 163, 
	164, 164, 165, 165, 166, 167, 358, 169, 
	170, 171, 172, 173, 174, 175, 176, 177, 
	177, 353, 179, 180, 181, 182, 183, 184, 
	185, 185, 186, 186, 187, 188, 360, 190, 
	191, 192, 193, 193, 194, 194, 195, 361, 
	196, 197, 197, 198, 197, 197, 198, 199, 
	200, 201, 201, 202, 202, 202, 203, 204, 
	194, 194, 195, 361, 206, 207, 208, 209, 
	210, 211, 212, 213, 213, 214, 214, 215, 
	363, 216, 271, 217, 217, 214, 218, 217, 
	217, 218, 218, 219, 220, 221, 222, 223, 
	224, 225, 268, 225, 226, 269, 228, 225, 
	225, 226, 228, 226, 227, 228, 229, 230, 
	231, 232, 233, 234, 234, 235, 235, 236, 
	240, 242, 237, 238, 239, 239, 240, 239, 
	239, 241, 241, 262, 245, 243, 244, 236, 
	240, 244, 246, 246, 247, 261, 248, 249, 
	250, 251, 252, 253, 254, 255, 256, 257, 
	258, 259, 260, 260, 260, 263, 264, 264, 
	265, 265, 265, 266, 267, 241, 241, 236, 
	240, 242, 245, 268, 269, 270, 225, 225, 
	226, 228, 273, 274, 275, 276, 277, 278, 
	279, 280, 281, 282, 283, 283, 284, 284, 
	285, 286, 365, 288, 289, 290, 291, 292, 
	292, 353, 294, 295, 296, 297, 298, 299, 
	300, 301, 301, 353, 302, 303, 303, 304, 
	305, 306, 307, 308, 302, 302, 3, 21, 
	25, 33, 309, 310, 310, 311, 312, 313, 
	314, 317, 309, 309, 37, 49, 57, 309, 
	309, 309, 309, 318, 319, 319, 320, 321, 
	324, 318, 318, 318, 318, 318, 318, 325, 
	326, 326, 327, 328, 329, 330, 331, 332, 
	325, 325, 84, 86, 89, 91, 325, 325, 
	333, 334, 334, 335, 336, 337, 333, 333, 
	333, 333, 338, 339, 339, 340, 341, 342, 
	343, 344, 347, 338, 338, 101, 108, 112, 
	120, 125, 338, 338, 338, 338, 348, 349, 
	349, 350, 351, 352, 348, 348, 348, 348, 
	353, 354, 354, 355, 356, 357, 359, 362, 
	364, 366, 367, 368, 353, 353, 144, 151, 
	162, 168, 353, 358, 358, 178, 189, 353, 
	360, 360, 353, 353, 205, 353, 353, 272, 
	353, 365, 365, 287, 293, 353, 353
};

static const short _eo_tokenizer_trans_actions[] = {
	219, 0, 1, 0, 209, 0, 242, 0, 
	0, 0, 0, 0, 0, 43, 0, 3, 
	0, 49, 49, 320, 49, 323, 0, 1, 
	211, 0, 0, 0, 3, 13, 284, 287, 
	0, 11, 281, 11, 11, 0, 1, 0, 
	1, 0, 0, 0, 41, 0, 0, 0, 
	0, 0, 0, 0, 47, 0, 0, 0, 
	45, 75, 0, 1, 0, 0, 59, 1, 
	3, 0, 1, 0, 57, 0, 221, 0, 
	0, 0, 5, 251, 0, 3, 0, 254, 
	0, 0, 0, 0, 0, 3, 0, 248, 
	0, 0, 0, 0, 0, 3, 0, 332, 
	73, 0, 0, 0, 0, 1, 3, 0, 
	1, 0, 0, 93, 0, 1, 0, 77, 
	0, 224, 0, 335, 91, 0, 0, 0, 
	0, 1, 3, 0, 1, 0, 0, 115, 
	0, 1, 0, 95, 0, 227, 0, 1, 
	97, 0, 0, 1, 101, 0, 1, 99, 
	0, 0, 0, 0, 1, 103, 131, 0, 
	1, 0, 117, 0, 230, 7, 260, 0, 
	263, 0, 1, 119, 153, 0, 1, 0, 
	0, 135, 1, 3, 0, 1, 0, 133, 
	0, 233, 0, 0, 0, 272, 0, 0, 
	0, 0, 0, 3, 0, 269, 0, 0, 
	0, 0, 1, 137, 0, 0, 0, 0, 
	0, 3, 0, 338, 151, 0, 0, 0, 
	0, 1, 3, 0, 1, 0, 0, 169, 
	0, 1, 0, 155, 0, 236, 9, 275, 
	0, 278, 0, 1, 157, 207, 0, 1, 
	0, 0, 173, 1, 3, 0, 1, 0, 
	171, 0, 239, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 179, 0, 
	0, 1, 0, 1, 3, 0, 23, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	1, 181, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 1, 3, 0, 21, 0, 
	0, 0, 0, 1, 0, 1, 3, 0, 
	0, 15, 290, 15, 0, 1, 0, 0, 
	0, 0, 1, 3, 0, 1, 0, 0, 
	17, 293, 296, 17, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 0, 1, 3, 
	0, 0, 0, 25, 299, 25, 25, 0, 
	1, 0, 1, 0, 0, 0, 0, 0, 
	0, 27, 27, 302, 27, 305, 27, 0, 
	1, 0, 0, 1, 0, 1, 0, 0, 
	0, 0, 0, 0, 1, 0, 1, 0, 
	0, 3, 3, 0, 33, 311, 33, 0, 
	1, 0, 1, 0, 0, 0, 31, 31, 
	31, 0, 0, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 3, 0, 37, 0, 
	3, 0, 39, 0, 1, 0, 0, 1, 
	3, 0, 1, 0, 0, 35, 314, 35, 
	35, 317, 35, 0, 3, 0, 29, 308, 
	29, 29, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 0, 1, 
	3, 0, 19, 0, 0, 0, 0, 0, 
	1, 185, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 183, 213, 0, 1, 326, 
	55, 55, 55, 55, 215, 217, 0, 0, 
	0, 0, 63, 0, 1, 326, 329, 329, 
	329, 0, 65, 71, 0, 0, 0, 67, 
	245, 69, 61, 81, 0, 1, 326, 329, 
	0, 83, 89, 85, 257, 87, 79, 107, 
	0, 1, 326, 55, 55, 55, 55, 0, 
	109, 113, 0, 0, 0, 0, 111, 105, 
	123, 0, 1, 326, 329, 0, 125, 129, 
	127, 121, 141, 0, 1, 326, 55, 55, 
	55, 55, 0, 143, 149, 0, 0, 0, 
	0, 0, 145, 266, 147, 139, 161, 0, 
	1, 326, 329, 0, 163, 167, 165, 159, 
	189, 0, 1, 326, 55, 55, 55, 55, 
	55, 55, 55, 0, 191, 205, 0, 0, 
	0, 0, 197, 0, 1, 0, 0, 195, 
	0, 1, 201, 177, 0, 199, 175, 0, 
	193, 0, 1, 0, 0, 203, 187
};

static const short _eo_tokenizer_to_state_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 51, 0, 
	0, 0, 0, 0, 0, 51, 0, 0, 
	0, 0, 0, 0, 0, 0, 51, 0, 
	0, 0, 0, 0, 0, 51, 0, 0, 
	0, 0, 0, 0, 0, 51, 0, 0, 
	0, 0, 51, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 51, 0, 0, 0, 
	0, 51, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0
};

static const short _eo_tokenizer_from_state_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 53, 0, 
	0, 0, 0, 0, 0, 53, 0, 0, 
	0, 0, 0, 0, 0, 0, 53, 0, 
	0, 0, 0, 0, 0, 53, 0, 0, 
	0, 0, 0, 0, 0, 53, 0, 0, 
	0, 0, 53, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 53, 0, 0, 0, 
	0, 53, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0
};

static const short _eo_tokenizer_eof_trans[] = {
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 58, 58, 58, 58, 58, 58, 58, 
	58, 97, 97, 97, 97, 97, 97, 108, 
	108, 108, 108, 117, 117, 117, 117, 117, 
	117, 128, 128, 128, 128, 128, 128, 128, 
	128, 128, 128, 128, 128, 128, 128, 128, 
	151, 151, 151, 151, 151, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 205, 205, 205, 
	205, 205, 205, 216, 216, 216, 216, 216, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 230, 230, 
	230, 230, 230, 230, 230, 230, 0, 469, 
	470, 470, 470, 470, 470, 0, 483, 484, 
	484, 484, 484, 488, 489, 490, 0, 498, 
	499, 499, 500, 501, 502, 0, 513, 514, 
	514, 514, 514, 514, 519, 0, 527, 528, 
	528, 529, 0, 540, 541, 541, 541, 541, 
	541, 547, 548, 549, 0, 557, 558, 558, 
	559, 0, 573, 574, 574, 574, 579, 574, 
	584, 587, 574, 590, 574, 593, 574, 574, 
	598
};

static const int eo_tokenizer_start = 302;
static const int eo_tokenizer_first_final = 302;
static const int eo_tokenizer_error = -1;

static const int eo_tokenizer_en_tokenize_accessor = 309;
static const int eo_tokenizer_en_tokenize_params = 318;
static const int eo_tokenizer_en_tokenize_property = 325;
static const int eo_tokenizer_en_tokenize_properties = 333;
static const int eo_tokenizer_en_tokenize_method = 338;
static const int eo_tokenizer_en_tokenize_methods = 348;
static const int eo_tokenizer_en_tokenize_class = 353;
static const int eo_tokenizer_en_main = 302;


#line 1017 "lib/eolian/eo_lexer.rl"


Eina_Bool
eo_tokenizer_walk(Eo_Tokenizer *toknz, const char *source)
{
   INF("tokenize %s...", source);
   toknz->source = eina_stringshare_add(source);

   FILE *stream;
   Eina_Bool ret = EINA_TRUE;

   int done = 0;
   int have = 0;
   int offset = 0;

   stream = fopen(toknz->source, "rb");
   if (!stream)
     {
        ERR("unable to read in %s", toknz->source);
        return EINA_FALSE;
     }

   
#line 1308 "lib/eolian/eo_lexer.c"
	{
	 toknz->cs = eo_tokenizer_start;
	 toknz->ts = 0;
	 toknz->te = 0;
	 toknz->act = 0;
	}

#line 1040 "lib/eolian/eo_lexer.rl"

   while (!done)
     {
        int len;
        int space;

        toknz->p = toknz->buf + have;
        space = BUFSIZE - have;

        if (space == 0)
          {
             fclose(stream);
             ABORT(toknz, "out of buffer space");
          }

        len = fread(toknz->p, 1, space, stream);
        if (len == 0) break;
        toknz->pe = toknz->p + len;

        if (len < space)
          {
             toknz->eof = toknz->pe;
             done = 1;
          }

        
#line 1343 "lib/eolian/eo_lexer.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( ( toknz->p) == ( toknz->pe) )
		goto _test_eof;
_resume:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_from_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 37:
#line 1 "NONE"
	{ toknz->ts = ( toknz->p);}
	break;
#line 1362 "lib/eolian/eo_lexer.c"
		}
	}

	_keys = _eo_tokenizer_trans_keys + _eo_tokenizer_key_offsets[ toknz->cs];
	_trans = _eo_tokenizer_index_offsets[ toknz->cs];

	_klen = _eo_tokenizer_single_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*( toknz->p)) < *_mid )
				_upper = _mid - 1;
			else if ( (*( toknz->p)) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _eo_tokenizer_range_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*( toknz->p)) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*( toknz->p)) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	_trans = _eo_tokenizer_indicies[_trans];
_eof_trans:
	 toknz->cs = _eo_tokenizer_trans_targs[_trans];

	if ( _eo_tokenizer_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _eo_tokenizer_actions + _eo_tokenizer_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 355 "lib/eolian/eo_lexer.rl"
	{
      toknz->current_line += 1;
      DBG("inc[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 1:
#line 360 "lib/eolian/eo_lexer.rl"
	{
      toknz->saved.line = toknz->current_line;
      DBG("save line[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 2:
#line 365 "lib/eolian/eo_lexer.rl"
	{
      toknz->saved.tok = ( toknz->p);
      DBG("save token[%d] %p %c", toknz->cs, ( toknz->p), *( toknz->p));
   }
	break;
	case 3:
#line 441 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->ret != NULL)
        ABORT(toknz, "accessor has already a return type");
      toknz->tmp.accessor->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 4:
#line 448 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (!toknz->tmp.accessor->ret) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.accessor->ret->comment != NULL)
        ABORT(toknz, "accessor return type has already a comment");
      toknz->tmp.accessor->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.accessor->ret->comment);
   }
	break;
	case 5:
#line 457 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      toknz->tmp.accessor->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 6:
#line 471 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.accessor_param = _eo_tokenizer_accessor_param_get(toknz, ( toknz->p));
   }
	break;
	case 7:
#line 475 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor_param)
         ABORT(toknz, "No accessor param!!!");
      toknz->tmp.accessor_param->attrs = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.accessor->params =
         eina_list_append(toknz->tmp.accessor->params, toknz->tmp.accessor_param);
      toknz->tmp.accessor_param = NULL;
   }
	break;
	case 8:
#line 504 "lib/eolian/eo_lexer.rl"
	{
      const char *c = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      if (toknz->tmp.param == NULL)
        ABORT(toknz, "no parameter set to associate this comment to: %s", c);
      toknz->tmp.param->comment = c;
      toknz->tmp.param = NULL;
   }
	break;
	case 9:
#line 512 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.param = _eo_tokenizer_param_get(toknz, ( toknz->p));
      if (toknz->tmp.params)
        *(toknz->tmp.params) = eina_list_append(*(toknz->tmp.params), toknz->tmp.param);
      else
        ABORT(toknz, "got a param but there is no property nor method waiting for it");
      INF("        %s : %s", toknz->tmp.param->name, toknz->tmp.param->type);
   }
	break;
	case 10:
#line 612 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.prop != NULL)
        ABORT(toknz, "there is a pending property definition %s", toknz->tmp.prop->name);
      toknz->tmp.prop = _eo_tokenizer_property_get(toknz, ( toknz->p));
   }
	break;
	case 11:
#line 652 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL)
        ABORT(toknz, "method '%s' has already a return type", toknz->tmp.meth->name);
      toknz->tmp.meth->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 12:
#line 659 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.meth->ret->comment != NULL)
        ABORT(toknz, "method '%s' return type has already a comment", toknz->tmp.meth->name);
      toknz->tmp.meth->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.meth->ret->comment);
   }
	break;
	case 13:
#line 668 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 14:
#line 673 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->obj_const = EINA_TRUE;
      INF("        obj const");
   }
	break;
	case 15:
#line 735 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.meth != NULL)
        ABORT(toknz, "there is a pending method definition %s", toknz->tmp.meth->name);
      toknz->tmp.meth = _eo_tokenizer_method_get(toknz, ( toknz->p));
   }
	break;
	case 16:
#line 767 "lib/eolian/eo_lexer.rl"
	{
      const char *base = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.str_items = eina_list_append(toknz->tmp.str_items, base);
   }
	break;
	case 17:
#line 772 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.kls->inherits = toknz->tmp.str_items;
      toknz->tmp.str_items = NULL;
   }
	break;
	case 18:
#line 820 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.event = _eo_tokenizer_event_get(toknz, ( toknz->p));
      toknz->tmp.kls->events = eina_list_append(toknz->tmp.kls->events, toknz->tmp.event);
   }
	break;
	case 19:
#line 826 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->comment != NULL)
        ABORT(toknz, "event %s has already a comment", toknz->tmp.event->name);
      toknz->tmp.event->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      toknz->tmp.event = NULL;
   }
	break;
	case 20:
#line 834 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->legacy_prefix != NULL)
        ABORT(toknz, "A legacy prefix has already been given");
      toknz->tmp.kls->legacy_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 21:
#line 843 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->eo_prefix != NULL)
        ABORT(toknz, "An Eo prefix has already been given");
      toknz->tmp.kls->eo_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 22:
#line 852 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->data_type != NULL)
        ABORT(toknz, "A data type has already been given");
      toknz->tmp.kls->data_type = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 23:
#line 865 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
        toknz->tmp.impl = _eo_tokenizer_implement_get(toknz, ( toknz->p));
        toknz->tmp.kls->implements = eina_list_append(toknz->tmp.kls->implements, toknz->tmp.impl);
   }
	break;
	case 24:
#line 871 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (toknz->tmp.impl->legacy)
           ABORT(toknz, "Legacy section already allocated for implement item");
        toknz->tmp.impl->legacy = calloc(1, sizeof(Eo_Implement_Legacy_Def));
   }
	break;
	case 25:
#line 878 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->function_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 26:
#line 885 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        toknz->tmp.impl_leg_param = calloc(1, sizeof(Eo_Implement_Legacy_Param_Def));
        toknz->tmp.impl->legacy->params = eina_list_append(
              toknz->tmp.impl->legacy->params, toknz->tmp.impl_leg_param);

        toknz->tmp.impl_leg_param->eo_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 27:
#line 894 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl_leg_param)
           ABORT(toknz, "No implement legacy param!!!");
        toknz->tmp.impl_leg_param->legacy_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 28:
#line 900 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl_leg_param)
           ABORT(toknz, "No implement legacy param!!!");
        toknz->tmp.impl_leg_param->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
   }
	break;
	case 29:
#line 906 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->ret_type= _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 30:
#line 913 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->ret_value = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 31:
#line 983 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_REGULAR;
   }
	break;
	case 32:
#line 986 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_ABSTRACT;
   }
	break;
	case 33:
#line 989 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_MIXIN;
   }
	break;
	case 34:
#line 992 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_INTERFACE;
   }
	break;
	case 35:
#line 996 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.kls != NULL)
        ABORT(toknz, "there is a pending class definition %s", toknz->tmp.kls->name);
      toknz->tmp.kls = _eo_tokenizer_class_get(toknz, ( toknz->p));
      toknz->tmp.kls->type = toknz->tmp.kls_type;
   }
	break;
	case 38:
#line 1 "NONE"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 39:
#line 433 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->comment != NULL)
        ABORT(toknz, "accessor has already a comment");
      toknz->tmp.accessor->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.accessor->comment);
   }}
	break;
	case 40:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 41:
#line 496 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 42:
#line 497 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 43:
#line 462 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 44:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 45:
#line 492 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 46:
#line 495 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 47:
#line 462 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 48:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 49:
#line 495 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 50:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 51:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 52:
#line 521 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 325; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 338; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 53:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 54:
#line 537 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 55:
#line 539 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 56:
#line 521 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 325; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 338; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 57:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 58:
#line 539 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 59:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 60:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 61:
#line 546 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      get {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, GETTER);
      toknz->current_nesting++;
      { toknz->cs = 309; goto _again;}
   }}
	break;
	case 62:
#line 553 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      set {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, SETTER);
      toknz->current_nesting++;
      { toknz->cs = 309; goto _again;}
   }}
	break;
	case 63:
#line 560 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      keys {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->keys);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 64:
#line 567 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      values {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->values);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 65:
#line 574 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->values) == 0)
        WRN("property '%s' has no values.", toknz->tmp.prop->name);
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->current_nesting--;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 66:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 67:
#line 593 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 68:
#line 574 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->values) == 0)
        WRN("property '%s' has no values.", toknz->tmp.prop->name);
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->current_nesting--;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 69:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 70:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 71:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 72:
#line 605 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      INF("    %s {", toknz->tmp.prop->name);
      toknz->current_nesting++;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 73:
#line 618 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 74:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 75:
#line 627 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 76:
#line 618 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 77:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 78:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 79:
#line 636 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->comment != NULL)
        ABORT(toknz, "method has already a comment");
      toknz->tmp.meth->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.meth->comment);
   }}
	break;
	case 80:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 81:
#line 644 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("      params {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.meth->params);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 82:
#line 720 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 83:
#line 721 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 84:
#line 679 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (eina_list_count(toknz->tmp.meth->params) == 0)
        WRN("method '%s' has no parameters.", toknz->tmp.meth->name);
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_DESTRUCTOR:
          l = &toknz->tmp.kls->destructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->current_nesting--;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 85:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 86:
#line 715 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 87:
#line 719 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 88:
#line 679 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (eina_list_count(toknz->tmp.meth->params) == 0)
        WRN("method '%s' has no parameters.", toknz->tmp.meth->name);
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_DESTRUCTOR:
          l = &toknz->tmp.kls->destructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->current_nesting--;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 89:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 90:
#line 719 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 91:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 92:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 93:
#line 728 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    %s {", toknz->tmp.meth->name);
      toknz->current_nesting++;
      { toknz->cs = 338; goto _again;}
   }}
	break;
	case 94:
#line 741 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 95:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 96:
#line 751 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 97:
#line 741 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 98:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 99:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 100:
#line 760 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->comment != NULL)
        ABORT(toknz, "class %s has already a comment", toknz->tmp.kls->name);
      toknz->tmp.kls->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }}
	break;
	case 101:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 102:
#line 778 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 103:
#line 781 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 104:
#line 784 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  constructors {");
      toknz->current_methods_type = METH_CONSTRUCTOR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 105:
#line 791 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  destructors {");
      toknz->current_methods_type = METH_DESTRUCTOR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 106:
#line 798 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  properties {");
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 107:
#line 804 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  begin methods");
      toknz->current_methods_type = METH_REGULAR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 108:
#line 811 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 302; goto _again;}
   }}
	break;
	case 109:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 110:
#line 958 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 111:
#line 961 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 112:
#line 962 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 113:
#line 963 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 114:
#line 778 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 115:
#line 781 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 116:
#line 811 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 302; goto _again;}
   }}
	break;
	case 117:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 118:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 119:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 120:
#line 976 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("begin class: %s", toknz->tmp.kls->name);
      toknz->current_nesting++;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 121:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 122:
#line 1011 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 123:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 124:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
#line 2678 "lib/eolian/eo_lexer.c"
		}
	}

_again:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_to_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 36:
#line 1 "NONE"
	{ toknz->ts = 0;}
	break;
#line 2691 "lib/eolian/eo_lexer.c"
		}
	}

	if ( ++( toknz->p) != ( toknz->pe) )
		goto _resume;
	_test_eof: {}
	if ( ( toknz->p) == ( toknz->eof) )
	{
	if ( _eo_tokenizer_eof_trans[ toknz->cs] > 0 ) {
		_trans = _eo_tokenizer_eof_trans[ toknz->cs] - 1;
		goto _eof_trans;
	}
	}

	_out: {}
	}

#line 1066 "lib/eolian/eo_lexer.rl"

        if ( toknz->cs == 
#line 2712 "lib/eolian/eo_lexer.c"
-1
#line 1067 "lib/eolian/eo_lexer.rl"
 )
          {
             ERR("%s: wrong termination", source);
             ret = EINA_FALSE;
             break;
          }

        if ( toknz->ts == 0 )
          have = 0;
        else
          {
             DBG("move data and pointers before buffer feed");
             have = toknz->pe - toknz->ts;
             offset = toknz->ts - toknz->buf;
             memmove(toknz->buf, toknz->ts, have);
             toknz->te -= offset;
             toknz->ts = toknz->buf;
          }

        if (toknz->saved.tok != NULL)
          {
             if ((have == 0) || ((toknz->saved.tok - offset) < toknz->buf))
               {
                  WRN("reset lost saved token %p", toknz->saved.tok);
                  toknz->saved.tok = NULL;
               }
             else
               toknz->saved.tok -= offset;
          }
     }

   fclose(stream);

   return ret;
}

static Eina_Bool
eo_tokenizer_mem_walk(Eo_Tokenizer *toknz, const char *source, char *buffer, unsigned int len)
{
   INF("tokenize %s...", source);
   toknz->source = eina_stringshare_add(source);

   Eina_Bool ret = EINA_TRUE;

   
#line 2760 "lib/eolian/eo_lexer.c"
	{
	 toknz->cs = eo_tokenizer_start;
	 toknz->ts = 0;
	 toknz->te = 0;
	 toknz->act = 0;
	}

#line 1112 "lib/eolian/eo_lexer.rl"

   toknz->p = buffer;

   toknz->pe = toknz->p + len;

   toknz->eof = toknz->pe;

   
#line 2777 "lib/eolian/eo_lexer.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( ( toknz->p) == ( toknz->pe) )
		goto _test_eof;
_resume:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_from_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 37:
#line 1 "NONE"
	{ toknz->ts = ( toknz->p);}
	break;
#line 2796 "lib/eolian/eo_lexer.c"
		}
	}

	_keys = _eo_tokenizer_trans_keys + _eo_tokenizer_key_offsets[ toknz->cs];
	_trans = _eo_tokenizer_index_offsets[ toknz->cs];

	_klen = _eo_tokenizer_single_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*( toknz->p)) < *_mid )
				_upper = _mid - 1;
			else if ( (*( toknz->p)) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _eo_tokenizer_range_lengths[ toknz->cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*( toknz->p)) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*( toknz->p)) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	_trans = _eo_tokenizer_indicies[_trans];
_eof_trans:
	 toknz->cs = _eo_tokenizer_trans_targs[_trans];

	if ( _eo_tokenizer_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _eo_tokenizer_actions + _eo_tokenizer_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 355 "lib/eolian/eo_lexer.rl"
	{
      toknz->current_line += 1;
      DBG("inc[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 1:
#line 360 "lib/eolian/eo_lexer.rl"
	{
      toknz->saved.line = toknz->current_line;
      DBG("save line[%d] %d", toknz->cs, toknz->current_line);
   }
	break;
	case 2:
#line 365 "lib/eolian/eo_lexer.rl"
	{
      toknz->saved.tok = ( toknz->p);
      DBG("save token[%d] %p %c", toknz->cs, ( toknz->p), *( toknz->p));
   }
	break;
	case 3:
#line 441 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->ret != NULL)
        ABORT(toknz, "accessor has already a return type");
      toknz->tmp.accessor->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 4:
#line 448 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (!toknz->tmp.accessor->ret) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.accessor->ret->comment != NULL)
        ABORT(toknz, "accessor return type has already a comment");
      toknz->tmp.accessor->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.accessor->ret->comment);
   }
	break;
	case 5:
#line 457 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      toknz->tmp.accessor->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 6:
#line 471 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.accessor_param = _eo_tokenizer_accessor_param_get(toknz, ( toknz->p));
   }
	break;
	case 7:
#line 475 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.accessor_param)
         ABORT(toknz, "No accessor param!!!");
      toknz->tmp.accessor_param->attrs = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.accessor->params =
         eina_list_append(toknz->tmp.accessor->params, toknz->tmp.accessor_param);
      toknz->tmp.accessor_param = NULL;
   }
	break;
	case 8:
#line 504 "lib/eolian/eo_lexer.rl"
	{
      const char *c = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      if (toknz->tmp.param == NULL)
        ABORT(toknz, "no parameter set to associate this comment to: %s", c);
      toknz->tmp.param->comment = c;
      toknz->tmp.param = NULL;
   }
	break;
	case 9:
#line 512 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.param = _eo_tokenizer_param_get(toknz, ( toknz->p));
      if (toknz->tmp.params)
        *(toknz->tmp.params) = eina_list_append(*(toknz->tmp.params), toknz->tmp.param);
      else
        ABORT(toknz, "got a param but there is no property nor method waiting for it");
      INF("        %s : %s", toknz->tmp.param->name, toknz->tmp.param->type);
   }
	break;
	case 10:
#line 612 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.prop != NULL)
        ABORT(toknz, "there is a pending property definition %s", toknz->tmp.prop->name);
      toknz->tmp.prop = _eo_tokenizer_property_get(toknz, ( toknz->p));
   }
	break;
	case 11:
#line 652 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL)
        ABORT(toknz, "method '%s' has already a return type", toknz->tmp.meth->name);
      toknz->tmp.meth->ret = _eo_tokenizer_return_get(toknz, ( toknz->p));
   }
	break;
	case 12:
#line 659 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->ret != NULL) ABORT(toknz, "No ret!!!");
      if (toknz->tmp.meth->ret->comment != NULL)
        ABORT(toknz, "method '%s' return type has already a comment", toknz->tmp.meth->name);
      toknz->tmp.meth->ret->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      INF("        %s", toknz->tmp.meth->ret->comment);
   }
	break;
	case 13:
#line 668 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->legacy = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 14:
#line 673 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      toknz->tmp.meth->obj_const = EINA_TRUE;
      INF("        obj const");
   }
	break;
	case 15:
#line 735 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.meth != NULL)
        ABORT(toknz, "there is a pending method definition %s", toknz->tmp.meth->name);
      toknz->tmp.meth = _eo_tokenizer_method_get(toknz, ( toknz->p));
   }
	break;
	case 16:
#line 767 "lib/eolian/eo_lexer.rl"
	{
      const char *base = _eo_tokenizer_token_get(toknz, ( toknz->p));
      toknz->tmp.str_items = eina_list_append(toknz->tmp.str_items, base);
   }
	break;
	case 17:
#line 772 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.kls->inherits = toknz->tmp.str_items;
      toknz->tmp.str_items = NULL;
   }
	break;
	case 18:
#line 820 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      toknz->tmp.event = _eo_tokenizer_event_get(toknz, ( toknz->p));
      toknz->tmp.kls->events = eina_list_append(toknz->tmp.kls->events, toknz->tmp.event);
   }
	break;
	case 19:
#line 826 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.event) ABORT(toknz, "No event!!!");
      if (toknz->tmp.event->comment != NULL)
        ABORT(toknz, "event %s has already a comment", toknz->tmp.event->name);
      toknz->tmp.event->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
      toknz->tmp.event = NULL;
   }
	break;
	case 20:
#line 834 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->legacy_prefix != NULL)
        ABORT(toknz, "A legacy prefix has already been given");
      toknz->tmp.kls->legacy_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 21:
#line 843 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->eo_prefix != NULL)
        ABORT(toknz, "An Eo prefix has already been given");
      toknz->tmp.kls->eo_prefix = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 22:
#line 852 "lib/eolian/eo_lexer.rl"
	{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->data_type != NULL)
        ABORT(toknz, "A data type has already been given");
      toknz->tmp.kls->data_type = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 23:
#line 865 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
        toknz->tmp.impl = _eo_tokenizer_implement_get(toknz, ( toknz->p));
        toknz->tmp.kls->implements = eina_list_append(toknz->tmp.kls->implements, toknz->tmp.impl);
   }
	break;
	case 24:
#line 871 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (toknz->tmp.impl->legacy)
           ABORT(toknz, "Legacy section already allocated for implement item");
        toknz->tmp.impl->legacy = calloc(1, sizeof(Eo_Implement_Legacy_Def));
   }
	break;
	case 25:
#line 878 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->function_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 26:
#line 885 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        toknz->tmp.impl_leg_param = calloc(1, sizeof(Eo_Implement_Legacy_Param_Def));
        toknz->tmp.impl->legacy->params = eina_list_append(
              toknz->tmp.impl->legacy->params, toknz->tmp.impl_leg_param);

        toknz->tmp.impl_leg_param->eo_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 27:
#line 894 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl_leg_param)
           ABORT(toknz, "No implement legacy param!!!");
        toknz->tmp.impl_leg_param->legacy_name = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 28:
#line 900 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl_leg_param)
           ABORT(toknz, "No implement legacy param!!!");
        toknz->tmp.impl_leg_param->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-2);
   }
	break;
	case 29:
#line 906 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->ret_type= _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 30:
#line 913 "lib/eolian/eo_lexer.rl"
	{
        if (!toknz->tmp.impl) ABORT(toknz, "No implement!!!");
        if (!toknz->tmp.impl->legacy)
           ABORT(toknz, "No legacy section");
        toknz->tmp.impl->legacy->ret_value = _eo_tokenizer_token_get(toknz, ( toknz->p));
   }
	break;
	case 31:
#line 983 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_REGULAR;
   }
	break;
	case 32:
#line 986 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_ABSTRACT;
   }
	break;
	case 33:
#line 989 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_MIXIN;
   }
	break;
	case 34:
#line 992 "lib/eolian/eo_lexer.rl"
	{
      toknz->tmp.kls_type = EOLIAN_CLASS_INTERFACE;
   }
	break;
	case 35:
#line 996 "lib/eolian/eo_lexer.rl"
	{
      if (toknz->tmp.kls != NULL)
        ABORT(toknz, "there is a pending class definition %s", toknz->tmp.kls->name);
      toknz->tmp.kls = _eo_tokenizer_class_get(toknz, ( toknz->p));
      toknz->tmp.kls->type = toknz->tmp.kls_type;
   }
	break;
	case 38:
#line 1 "NONE"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 39:
#line 433 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.accessor) ABORT(toknz, "No accessor!!!");
      if (toknz->tmp.accessor->comment != NULL)
        ABORT(toknz, "accessor has already a comment");
      toknz->tmp.accessor->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.accessor->comment);
   }}
	break;
	case 40:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 41:
#line 496 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 42:
#line 497 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 43:
#line 462 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 44:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 45:
#line 492 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 46:
#line 495 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 47:
#line 462 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      if (!toknz->tmp.prop) ABORT(toknz, "No prop!!!");
      toknz->tmp.prop->accessors = eina_list_append(toknz->tmp.prop->accessors, toknz->tmp.accessor);
      toknz->tmp.accessor = NULL;
      toknz->current_nesting--;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 48:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 49:
#line 495 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 50:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 51:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 52:
#line 521 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 325; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 338; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 53:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 54:
#line 537 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 55:
#line 539 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 56:
#line 521 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("      }");
      toknz->tmp.param = NULL;
      toknz->current_nesting--;
      if (toknz->tmp.prop)
        { toknz->cs = 325; goto _again;}
      else if (toknz->tmp.meth)
        { toknz->cs = 338; goto _again;}
      else
        ABORT(toknz, "leaving tokenize_params but there is no property nor method pending");
   }}
	break;
	case 57:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 58:
#line 539 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 59:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 60:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 61:
#line 546 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      get {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, GETTER);
      toknz->current_nesting++;
      { toknz->cs = 309; goto _again;}
   }}
	break;
	case 62:
#line 553 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      set {");
      toknz->tmp.accessor = _eo_tokenizer_accessor_get(toknz, SETTER);
      toknz->current_nesting++;
      { toknz->cs = 309; goto _again;}
   }}
	break;
	case 63:
#line 560 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      keys {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->keys);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 64:
#line 567 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("      values {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.prop->values);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 65:
#line 574 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->values) == 0)
        WRN("property '%s' has no values.", toknz->tmp.prop->name);
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->current_nesting--;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 66:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 67:
#line 593 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 68:
#line 574 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      if (eina_list_count(toknz->tmp.prop->values) == 0)
        WRN("property '%s' has no values.", toknz->tmp.prop->name);
      if (eina_list_count(toknz->tmp.prop->accessors) == 0)
        WRN("property '%s' has no accessors.", toknz->tmp.prop->name);
      INF("    }");
      toknz->tmp.kls->properties = eina_list_append(toknz->tmp.kls->properties, toknz->tmp.prop);
      toknz->tmp.prop = NULL;
      toknz->current_nesting--;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 69:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 70:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 71:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 72:
#line 605 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.prop) ABORT(toknz, "No property!!!");
      INF("    %s {", toknz->tmp.prop->name);
      toknz->current_nesting++;
      { toknz->cs = 325; goto _again;}
   }}
	break;
	case 73:
#line 618 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 74:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 75:
#line 627 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 76:
#line 618 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 77:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 78:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 79:
#line 636 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (toknz->tmp.meth->comment != NULL)
        ABORT(toknz, "method has already a comment");
      toknz->tmp.meth->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
      INF("        %s", toknz->tmp.meth->comment);
   }}
	break;
	case 80:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 81:
#line 644 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("      params {");
      toknz->current_nesting++;
      toknz->tmp.params = &(toknz->tmp.meth->params);
      { toknz->cs = 318; goto _again;}
   }}
	break;
	case 82:
#line 720 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 83:
#line 721 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;}
	break;
	case 84:
#line 679 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (eina_list_count(toknz->tmp.meth->params) == 0)
        WRN("method '%s' has no parameters.", toknz->tmp.meth->name);
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_DESTRUCTOR:
          l = &toknz->tmp.kls->destructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->current_nesting--;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 85:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 86:
#line 715 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 87:
#line 719 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 88:
#line 679 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      Eina_List **l = NULL;
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      if (eina_list_count(toknz->tmp.meth->params) == 0)
        WRN("method '%s' has no parameters.", toknz->tmp.meth->name);
      INF("    }");
      switch (toknz->current_methods_type) {
        case METH_CONSTRUCTOR:
          l = &toknz->tmp.kls->constructors;
          break;
        case METH_DESTRUCTOR:
          l = &toknz->tmp.kls->destructors;
          break;
        case METH_REGULAR:
          l = &toknz->tmp.kls->methods;
          break;
        default:
          ABORT(toknz, "unknown method type %d", toknz->current_methods_type);
      }
      toknz->tmp.meth->type = toknz->current_methods_type;
      *l = eina_list_append(*l, toknz->tmp.meth);
      toknz->tmp.meth = NULL;
      toknz->current_nesting--;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 89:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 90:
#line 719 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}}
	break;
	case 91:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 92:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 93:
#line 728 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.meth) ABORT(toknz, "No method!!!");
      INF("    %s {", toknz->tmp.meth->name);
      toknz->current_nesting++;
      { toknz->cs = 338; goto _again;}
   }}
	break;
	case 94:
#line 741 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 95:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 96:
#line 751 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 97:
#line 741 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      INF("  }");
      toknz->current_methods_type = METH_TYPE_LAST;
      toknz->current_nesting--;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 98:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 99:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 100:
#line 760 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      if (toknz->tmp.kls->comment != NULL)
        ABORT(toknz, "class %s has already a comment", toknz->tmp.kls->name);
      toknz->tmp.kls->comment = _eo_tokenizer_token_get(toknz, ( toknz->p)-1);
   }}
	break;
	case 101:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 102:
#line 778 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 103:
#line 781 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
   }}
	break;
	case 104:
#line 784 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  constructors {");
      toknz->current_methods_type = METH_CONSTRUCTOR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 105:
#line 791 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  destructors {");
      toknz->current_methods_type = METH_DESTRUCTOR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 106:
#line 798 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  properties {");
      toknz->current_nesting++;
      { toknz->cs = 333; goto _again;}
   }}
	break;
	case 107:
#line 804 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      INF("  begin methods");
      toknz->current_methods_type = METH_REGULAR;
      toknz->current_nesting++;
      { toknz->cs = 348; goto _again;}
   }}
	break;
	case 108:
#line 811 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 302; goto _again;}
   }}
	break;
	case 109:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 110:
#line 958 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 111:
#line 961 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 112:
#line 962 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 113:
#line 963 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 114:
#line 778 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 115:
#line 781 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
   }}
	break;
	case 116:
#line 811 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("end class: %s", toknz->tmp.kls->name);
      toknz->classes = eina_list_append(toknz->classes, toknz->tmp.kls);
      toknz->tmp.kls = NULL;
      toknz->current_nesting--;
      { toknz->cs = 302; goto _again;}
   }}
	break;
	case 117:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 118:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 119:
#line 370 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("comment[%d] line%03d:%03d", toknz->cs,
          toknz->saved.line, toknz->current_line);
   }}
	break;
	case 120:
#line 976 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      if (!toknz->tmp.kls) ABORT(toknz, "No class!!!");
      INF("begin class: %s", toknz->tmp.kls->name);
      toknz->current_nesting++;
      { toknz->cs = 353; goto _again;}
   }}
	break;
	case 121:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p)+1;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 122:
#line 1011 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;}
	break;
	case 123:
#line 379 "lib/eolian/eo_lexer.rl"
	{ toknz->te = ( toknz->p);( toknz->p)--;{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
	case 124:
#line 379 "lib/eolian/eo_lexer.rl"
	{{( toknz->p) = (( toknz->te))-1;}{
      DBG("error[%d]", toknz->cs);
      char *s, *d;
      char buf[BUFSIZE];
      for (s = ( toknz->p), d = buf; (s <= toknz->pe); s++)
        {
           if ((*s == '\r') || (*s == '\n'))
             break;
           *d++ = *s;
        }
      *d = '\0';
      ERR("error n:%d l:%d c:'%c': %s",
          toknz->current_nesting, toknz->current_line, *( toknz->p), buf);
      toknz->cs = eo_tokenizer_error;
      {( toknz->p)++; goto _out; }  /* necessary to stop scanners */
   }}
	break;
#line 4112 "lib/eolian/eo_lexer.c"
		}
	}

_again:
	_acts = _eo_tokenizer_actions + _eo_tokenizer_to_state_actions[ toknz->cs];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 ) {
		switch ( *_acts++ ) {
	case 36:
#line 1 "NONE"
	{ toknz->ts = 0;}
	break;
#line 4125 "lib/eolian/eo_lexer.c"
		}
	}

	if ( ++( toknz->p) != ( toknz->pe) )
		goto _resume;
	_test_eof: {}
	if ( ( toknz->p) == ( toknz->eof) )
	{
	if ( _eo_tokenizer_eof_trans[ toknz->cs] > 0 ) {
		_trans = _eo_tokenizer_eof_trans[ toknz->cs] - 1;
		goto _eof_trans;
	}
	}

	_out: {}
	}

#line 1120 "lib/eolian/eo_lexer.rl"

   if ( toknz->cs == 
#line 4146 "lib/eolian/eo_lexer.c"
-1
#line 1121 "lib/eolian/eo_lexer.rl"
 )
     {
        ERR("%s: wrong termination", source);
        ret = EINA_FALSE;
     }

   return ret;
}

Eo_Tokenizer*
eo_tokenizer_get(void)
{
   Eo_Tokenizer *toknz = calloc(1, sizeof(Eo_Tokenizer));
   if (!toknz) return NULL;

   toknz->ts = NULL;
   toknz->te = NULL;
   /* toknz->top = 0; */
   toknz->source = NULL;
   toknz->max_nesting = 10;
   toknz->current_line = 1;
   toknz->current_nesting = 0;
   toknz->current_methods_type = METH_TYPE_LAST;
   toknz->saved.tok = NULL;
   toknz->saved.line = 0;
   toknz->classes = NULL;

   return toknz;
}

static char *_accessor_type_str[ACCESSOR_TYPE_LAST] = { "setter", "getter" };
static char *_param_way_str[PARAM_WAY_LAST] = { "IN", "OUT", "INOUT" };

void
eo_tokenizer_dump(Eo_Tokenizer *toknz)
{
   const char *s;
   Eina_List *k, *l, *m;

   Eo_Class_Def *kls;
   Eo_Property_Def *prop;
   Eo_Method_Def *meth;
   Eo_Param_Def *param;
   Eo_Accessor_Def *accessor;
   Eo_Event_Def *sgn;
   /* Eo_Ret_Def *ret; */

   EINA_LIST_FOREACH(toknz->classes, k, kls)
     {
        printf("Class: %s (%s)\n",
               kls->name, (kls->comment ? kls->comment : "-"));
        printf("  inherits from :");
        EINA_LIST_FOREACH(kls->inherits, l, s)
           printf(" %s", s);
        printf("\n");
        printf("  implements:");
        EINA_LIST_FOREACH(kls->implements, l, s)
           printf(" %s", s);
        printf("\n");
        printf("  events:\n");
        EINA_LIST_FOREACH(kls->events, l, sgn)
           printf("    %s (%s)\n", sgn->name, sgn->comment);

        EINA_LIST_FOREACH(kls->constructors, l, meth)
          {
             printf("  constructors: %s\n", meth->name);
             if (meth->ret)
                printf("    return: %s (%s)\n", meth->ret->type, meth->ret->comment);
             printf("    legacy : %s\n", meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  printf("    param: %s %s : %s (%s)\n",
                         _param_way_str[param->way], param->name,
                         param->type, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->destructors, l, meth)
          {
             printf("  destructors: %s\n", meth->name);
             if (meth->ret)
                printf("    return: %s (%s)\n", meth->ret->type, meth->ret->comment);
             printf("    legacy : %s\n", meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  printf("    param: %s %s : %s (%s)\n",
                         _param_way_str[param->way], param->name,
                         param->type, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->properties, l, prop)
          {
             printf("  property: %s\n", prop->name);
             EINA_LIST_FOREACH(prop->keys, m, param)
               {
                  printf("    key: %s : %s (%s)\n",
                         param->name, param->type, param->comment);
               }
             EINA_LIST_FOREACH(prop->values, m, param)
               {
                  printf("    value: %s : %s (%s)\n",
                         param->name, param->type, param->comment);
               }
             EINA_LIST_FOREACH(prop->accessors, m, accessor)
               {
                  printf("    accessor: %s : %s (%s)\n",
                         (accessor->ret?accessor->ret->type:""),
                         _accessor_type_str[accessor->type],
                         accessor->comment);
                  printf("      legacy : %s\n", accessor->legacy);
               }
          }

        EINA_LIST_FOREACH(kls->methods, l, meth)
          {
             printf("  method: %s\n", meth->name);
             if (meth->ret)
                printf("    return: %s (%s)\n", meth->ret->type, meth->ret->comment);
             printf("    legacy : %s\n", meth->legacy);
             printf("    obj_const : %s\n", meth->obj_const?"true":"false");
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  printf("    param: %s %s : %s (%s)\n",
                         _param_way_str[param->way], param->name,
                         param->type, param->comment);
               }
          }

     }

}

Eina_Bool
eo_tokenizer_database_fill(const char *filename)
{
   Eina_Bool ret = EINA_FALSE;
   const char *s;
   Eina_List *k, *l, *m;

   Eo_Class_Def *kls;
   Eo_Property_Def *prop;
   Eo_Method_Def *meth;
   Eo_Param_Def *param;
   Eo_Accessor_Def *accessor;
   Eo_Event_Def *event;
   Eo_Implement_Def *impl;

   FILE *stream = NULL;
   char *buffer = NULL;

   Eo_Tokenizer *toknz = eo_tokenizer_get();
   if (!toknz)
     {
        ERR("can't create eo_tokenizer");
        goto end;
     }

   stream = fopen(filename, "rb");
   if (!stream)
     {
        ERR("unable to read in %s", filename);
        goto end;
     }

   buffer = malloc(BUFSIZE);
   if (!buffer)
     {
        ERR("unable to allocate read buffer");
        goto end;
     }

   unsigned int len = fread(buffer, 1, BUFSIZE, stream);

   if (!len)
     {
        ERR("%s: is an empty file", filename);
        goto end;
     }

   if (len == BUFSIZE)
      WRN("%s: buffer(%d) is full, might not be big enough.", filename, len);

   if (!eo_tokenizer_mem_walk(toknz, filename, buffer, len)) goto end;

   if (!toknz->classes)
     {
        ERR("No classes for file %s", filename);
        goto end;
     }

   EINA_LIST_FOREACH(toknz->classes, k, kls)
     {
        database_class_add(kls->name, kls->type);
        database_class_file_set(kls->name, filename);

        if (kls->comment) database_class_description_set(kls->name, kls->comment);

        EINA_LIST_FOREACH(kls->inherits, l, s)
           database_class_inherit_add(kls->name, s);

        if (kls->legacy_prefix)
          {
             database_class_legacy_prefix_set(kls->name, kls->legacy_prefix);
          }
        if (kls->eo_prefix)
          {
             database_class_eo_prefix_set(kls->name, kls->eo_prefix);
          }
        if (kls->data_type)
          {
             database_class_data_type_set(kls->name, kls->data_type);
          }
        EINA_LIST_FOREACH(kls->constructors, l, meth)
          {
             Eolian_Function foo_id = database_function_new(meth->name, CONSTRUCTOR);
             database_class_function_add(kls->name, foo_id);
             if (meth->ret) database_function_description_set(foo_id, EOLIAN_RETURN_COMMENT, meth->ret->comment);
             database_function_data_set(foo_id, EOLIAN_LEGACY, meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  database_method_parameter_add(foo_id, (Eolian_Parameter_Dir)param->way, param->type, param->name, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->destructors, l, meth)
          {
             Eolian_Function foo_id = database_function_new(meth->name, DESTRUCTOR);
             database_class_function_add(kls->name, foo_id);
             if (meth->ret) database_function_description_set(foo_id, EOLIAN_RETURN_COMMENT, meth->ret->comment);
             database_function_data_set(foo_id, EOLIAN_LEGACY, meth->legacy);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  database_method_parameter_add(foo_id, (Eolian_Parameter_Dir)param->way, param->type, param->name, param->comment);
               }
          }

        EINA_LIST_FOREACH(kls->properties, l, prop)
          {
             Eolian_Function foo_id = database_function_new(prop->name, UNRESOLVED);
             EINA_LIST_FOREACH(prop->keys, m, param)
               {
                  Eolian_Function_Parameter p = database_property_key_add(
                        foo_id, param->type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
                  database_parameter_own_set(p, param->own);
               }
             EINA_LIST_FOREACH(prop->values, m, param)
               {
                  Eolian_Function_Parameter p = database_property_value_add(
                        foo_id, param->type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
                  database_parameter_own_set(p, param->own);
               }
             EINA_LIST_FOREACH(prop->accessors, m, accessor)
               {
                  database_function_type_set(foo_id, (accessor->type == SETTER?SET:GET));
                  if (accessor->ret && accessor->ret->type)
                    {
                       database_function_return_type_set(foo_id,
                             accessor->type == SETTER?SET:GET, accessor->ret->type);
                       database_function_data_set(foo_id,
                             (accessor->type == SETTER?EOLIAN_PROP_SET_RETURN_COMMENT:EOLIAN_PROP_GET_RETURN_COMMENT),
                             accessor->ret->comment);
                       database_function_return_flag_set_as_warn_unused(foo_id,
                             accessor->type == SETTER?SET:GET, accessor->ret->warn_unused);
                       database_function_return_flag_set_own(foo_id,
                             accessor->type == SETTER?SET:GET, accessor->ret->own);
                       database_function_return_dflt_val_set(foo_id,
                             accessor->type == SETTER?SET:GET, accessor->ret->dflt_ret_val);
                    }
                  if (accessor->legacy)
                    {
                       database_function_data_set(foo_id,
                             (accessor->type == SETTER?EOLIAN_LEGACY_SET:EOLIAN_LEGACY_GET),
                             accessor->legacy);
                    }
                  database_function_description_set(foo_id,
                        (accessor->type == SETTER?EOLIAN_COMMENT_SET:EOLIAN_COMMENT_GET),
                        accessor->comment);
                  Eo_Accessor_Param *acc_param;
                  Eina_List *m2;
                  /* Only in get access, we check const attribute */
                  if (accessor->type == GETTER)
                    {
                       EINA_LIST_FOREACH(accessor->params, m2, acc_param)
                         {
                            Eolian_Function_Parameter desc = eolian_function_parameter_get(foo_id, acc_param->name);
                            if (!desc)
                              {
                                 printf("Error - %s not known as parameter of property %s\n", acc_param->name, prop->name);
                              }
                            else
                               if (strstr(acc_param->attrs, "const"))
                                 {
                                    database_parameter_get_const_attribute_set(desc, EINA_TRUE);
                                 }
                         }
                    }
               }
             database_class_function_add(kls->name, foo_id);
          }

        EINA_LIST_FOREACH(kls->methods, l, meth)
          {
             Eolian_Function foo_id = database_function_new(meth->name, METHOD_FUNC);
             database_class_function_add(kls->name, foo_id);
             if (meth->ret)
               {
                  database_function_data_set(foo_id, EOLIAN_METHOD_RETURN_TYPE, meth->ret->type);
                  database_function_description_set(foo_id, EOLIAN_RETURN_COMMENT, meth->ret->comment);
                  database_function_return_flag_set_as_warn_unused(foo_id,
                        METHOD_FUNC, meth->ret->warn_unused);
                  database_function_return_flag_set_own(foo_id, METHOD_FUNC, meth->ret->own);
                  database_function_return_dflt_val_set(foo_id,
                        METHOD_FUNC, meth->ret->dflt_ret_val);
               }
             database_function_description_set(foo_id, EOLIAN_COMMENT, meth->comment);
             database_function_data_set(foo_id, EOLIAN_LEGACY, meth->legacy);
             database_function_object_set_as_const(foo_id, meth->obj_const);
             EINA_LIST_FOREACH(meth->params, m, param)
               {
                  Eolian_Function_Parameter p = database_method_parameter_add(foo_id,
                        (Eolian_Parameter_Dir)param->way, param->type, param->name, param->comment);
                  database_parameter_nonull_set(p, param->nonull);
                  database_parameter_own_set(p, param->own);
               }
          }

        EINA_LIST_FOREACH(kls->implements, l, impl)
          {
             const char *class = impl->meth_name;
             Eina_Bool virtual_pure = EINA_FALSE;
             if (!strcmp(class, "Eo_Base::constructor"))
               {
                  Eolian_Function foo_id = database_function_new("constructor", DFLT_CONSTRUCTOR);
                  database_class_function_add(kls->name, foo_id);
                  continue;
               }
             if (!strcmp(class, "Eo_Base::destructor"))
               {
                  Eolian_Function foo_id = database_function_new("destructor", DFLT_DESTRUCTOR);
                  database_class_function_add(kls->name, foo_id);
                  continue;
               }
             if (!strcmp(class, "class::constructor"))
               {
                  database_class_ctor_enable_set(kls->name, EINA_TRUE);
                  continue;
               }
             if (!strcmp(class, "class::destructor"))
               {
                  database_class_dtor_enable_set(kls->name, EINA_TRUE);
                  continue;
               }
             if (!strncmp(class, "virtual::", 9)) virtual_pure = EINA_TRUE;
             char *func = strstr(class, "::");
             if (func) *func = '\0';
             func += 2;
             Eolian_Function_Type ftype = UNRESOLVED;
             char *type_as_str = strstr(func, "::");
             if (type_as_str)
               {
                  *type_as_str = '\0';
                  if (!strcmp(type_as_str+2, "set")) ftype = SET;
                  else if (!strcmp(type_as_str+2, "get")) ftype = GET;
               }
             if (virtual_pure)
               {
                  /* Search the function into the existing functions of the current class */
                  Eolian_Function foo_id = eolian_class_function_find_by_name(
                        kls->name, func, ftype);
                  if (!foo_id)
                    {
                       ERR("Error - %s not known in class %s", class + 9, kls->name);
                       goto end;
                    }
                  database_function_set_as_virtual_pure(foo_id);
                  continue;
               }
             Eolian_Implement impl_desc = database_implement_new(class, func, ftype);
             if (impl->legacy)
               {
                  Eo_Implement_Legacy_Def *eo_leg = impl->legacy;
                  Eolian_Implement_Legacy leg = database_implement_legacy_add(
                        impl_desc, eo_leg->function_name);
                  database_implement_legacy_return_add(leg, eo_leg->ret_type, eo_leg->ret_value);
                  if (eo_leg->params)
                    {
                       Eina_List *itr;
                       Eo_Implement_Legacy_Param_Def *p;
                       EINA_LIST_FOREACH(eo_leg->params, itr, p)
                          database_implement_legacy_param_add(leg, p->eo_name,
                                p->legacy_name, p->comment);
                    }
               }
             database_class_implement_add(kls->name, impl_desc);
          }

        EINA_LIST_FOREACH(kls->events, l, event)
          {
             Eolian_Event ev = database_event_new(event->name, event->comment);
             database_class_event_add(kls->name, ev);
          }

     }

   ret = EINA_TRUE;
end:
   if (buffer) free(buffer);
   if (stream) fclose(stream);
   if (toknz) eo_tokenizer_free(toknz);
   return ret;
}

void
eo_tokenizer_free(Eo_Tokenizer *toknz)
{
   Eo_Class_Def *kls;

   if (toknz->source)
     eina_stringshare_del(toknz->source);

   EINA_LIST_FREE(toknz->classes, kls)
      eo_definitions_class_def_free(kls);

   free(toknz);
}

